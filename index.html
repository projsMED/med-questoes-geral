<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-DJ6GXTCQNG"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-DJ6GXTCQNG');
  </script>
  <meta charset="UTF-8" />
  <title>Questões do Terceiro Período</title>
  <style>
	.enunciado,
	.alternatives label .alt-text-content, /* Texto das alternativas */
	.feedback,                         /* Feedback geral (ME, VF, Checkbox, Escrita) */
	.assertive-feedback,          /* Feedback específico de assertiva Checkbox */
  .escrita-item-label  /* Adicione esta linha */
	{
	  white-space: pre-wrap; /* Preserva espaços e newlines, permite quebra de linha */
	}
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: linear-gradient(135deg, #e3eeff 0%, #f7f4fd 100%);
      margin: 0;
      min-height: 100vh;
      padding: 0;
    }
    #container {
      max-width: 700px;
      margin: 36px auto 36px auto;
      padding: 32px 24px 28px 24px;
      background: #fff;
      border-radius: 20px;
      box-shadow: 0 6px 28px 0 #a3b1c633, 0 2px 4px #a3b1c644;
      border: 1px solid #e6eaff;
      min-height: 70vh;
    }
    h1 {
      text-align: center;
      font-family: 'Montserrat', 'Segoe UI', Arial, sans-serif;
      font-size: 2.1em;
      margin-bottom: 18px;
      color: #373853;
      letter-spacing: 1px;
      user-select: none;
    }
    .tutorial {
      background: #f0f5ff;
      border: 1px solid #b9d3fa;
      border-radius: 12px;
      padding: 16px 22px 10px 22px;
      margin-bottom: 22px;
      font-size: 1.07em;
      color: #324a78;
      box-shadow: 0 1px 8px #b9d3fa22;
      line-height: 1.55;
      user-select: none;
    }
    .cloud-quiz-btn {
      background: linear-gradient(90deg, #59c7f3 0%, #91eac9 100%);
      color: #203447;
      border: none;
      border-radius: 7px;
      padding: 7px 22px;
      font-size: 1em;
      font-weight: 500;
      cursor: pointer;
      box-shadow: 0 2px 8px #59c7f333;
      transition: background 0.16s, box-shadow 0.16s;
      margin-bottom: 12px;
      margin-left: 0;
      margin-right: 13px;
      letter-spacing: 0.02em;
      user-select: none;
    }
    .cloud-quiz-btn:hover {
      background: linear-gradient(90deg, #23b6ea 0%, #47e4a1 100%);
      color: #fff;
    }
    .cloud-quiz-list {
      background: #f9fcff;
      border: 1px solid #b9d3fa;
      border-radius: 10px;
      padding: 18px 18px 10px 18px;
      margin-bottom: 18px;
      box-shadow: 0 1px 8px #b9d3fa22;
      font-size: 1.05em;
      color: #324a78;
      user-select: none;
    }
    .cloud-quiz-list ul {
      list-style: none;
      padding-left: 10px;
      margin: 0 0 8px 0;
    }
    .cloud-quiz-list li {
      margin: 3px 0 3px 0;
    }
    .cloud-quiz-list .folder {
      font-weight: bold;
      margin-top: 6px;
      color: #0d2d48;
    }
    .cloud-quiz-list .quiz-link {
      color: #1a4f7a;
      text-decoration: underline;
      cursor: pointer;
      background: none;
      border: none;
      font: inherit;
      padding: 2px 0;
      margin-left: 7px;
      transition: color 0.15s;
	  text-align: left;
    }
    .cloud-quiz-list .quiz-link:hover {
      color: #0e866a;
      text-decoration: underline;
      background: #e0f7fa;
    }
    input[type="file"] {
      margin-bottom: 18px;
      padding: 6px 0;
      font-size: 1em;
      border: none;
      background: transparent;
    }
    .options-bar {
      display: flex;
      gap: 10px;
      margin-bottom: 18px;
      justify-content: flex-start;
      flex-wrap: wrap;
      align-items: center;
      user-select: none;
    }
    .options-bar label {
      font-size: 1em;
      background: #f8fafd;
      border-radius: 8px;
      padding: 4px 10px 4px 7px;
      box-shadow: 0 1px 4px #0001;
      cursor: pointer;
      transition: background .2s;
      border: 1px solid #d3e1fa;
      margin-bottom: 2px;
      user-select: none;
    }
    .options-bar input[type="checkbox"] {
      margin-right: 6px;
    }
    #resetQuizBtn {
      background: linear-gradient(90deg, #f06d6d 0%, #ffb199 100%);
      color: #fff;
      border: none;
      border-radius: 7px;
      padding: 7px 22px;
      font-size: 1em;
      font-weight: 500;
      cursor: pointer;
      box-shadow: 0 2px 8px #f06d6d22;
      transition: background 0.16s, box-shadow 0.16s;
      margin-left: 8px;
      margin-bottom: 2px;
      user-select: none;
    }
    #resetQuizBtn:hover {
      background: linear-gradient(90deg, #d43a3a 0%, #ff7e5f 100%);
      box-shadow: 0 4px 18px #f06d6d33;
    }
    .question-block {
      margin-bottom: 35px;
      border-radius: 12px;
      border: 1px solid #e8e8f7;
      background: #f7f8fc;
      padding: 20px 20px 18px 20px;
      box-shadow: 0 2px 10px #cbd6f320;
      transition: box-shadow 0.15s;
    }
    .question-block:hover {
      box-shadow: 0 6px 18px #b3b9e833;
      border-color: #bacfff;
    }
    .question-block strong {
      color: #4b53b7;
      font-size: 1.09em;
      letter-spacing: 0.3px;
    }
    .alternatives {
      margin: 16px 0 0 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .enunciado {
      font-size: 1.25em;
      line-height: 1.4;
      margin-bottom: 2px;
      color: #313265;
    }
    .alternatives label {
      display: flex;
      align-items: flex-start;
      background: #fff;
      border-radius: 8px;
      border: 1px solid #dde2f7;
      font-size: 1.25em;
      padding: 7px 10px 7px 0;
      cursor: pointer;
      transition: background 0.15s, border 0.15s;
      min-height: 36px;
      user-select: text;
      position: relative;
      gap: 8px;
    }
    .alt-text-content {
      flex: 1 1 0;
      display: block;
      min-width: 0;
      word-break: break-word;
    }
    .alternatives label:hover {
      background: #e9f3ff;
      border-color: #adc9ff;
    }
    .alternatives input[type="radio"],
    .alternatives input[type="checkbox"] {
      accent-color: #6b7cff;
      margin: 0 13px 0 7px;
      transform: scale(1.08);
    }
    .alt-elim-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 43px;
      height: 43px;
      margin-left: 8px;
      border-radius: 50%;
      background: #eef2f6;
      border: 1.5px solid #c6d7ee;
      color: #444;
      cursor: pointer;
      font-size: 1.13em;
      font-weight: bold;
      transition: background 0.15s, border 0.15s, color 0.13s;
      outline: none;
      user-select: none;
    }
    .alt-elim-btn:hover,
    .alt-elim-btn:focus {
      background: #e0e8f9;
      color: #0e866a;
      border-color: #91b6e6;
    }
    .eliminada {
      color: #b7b7b7 !important;
      text-decoration: line-through;
      font-style: italic;
      opacity: 0.8;
      transition: color 0.15s, opacity 0.15s;
    }
    .feedback {
      margin-top: 10px;
      font-weight: 430;
      min-height: 30px;
      border-radius: 8px;
      font-size: 1.1em;
      padding: 7px 12px 7px 12px;
      background: #f5f5fc;
      border: 1px solid #e5e7fb;
      margin-bottom: 4px;
    }
	.feedback neutral{
	user-select: none;
	font-weight: 430;
	}
	.feedback.correct {
	  border: 5px solid #228b22; /* Borda verde densa. Ajuste a espessura (3px) conforme necessário */
	}
	.feedback.incorrect {
	  border: 5px solid #d5001a; /* Borda vermelha densa. Ajuste a espessura (3px) conforme necessário */
	}
    .feedback.neutral {
      color: #3a3c50;
      background: #f4f6ff;
      border-color: #c2d8f9;
    }
    .assertive-feedback {
      font-size: 1.25em;
      margin: 2px 0 2px 32px;
	  padding: 5px 5px 5px 5px;
    }
    .assertive-feedback.correct {
	border: 3px solid #228b22;
    }
    .assertive-feedback.incorrect {
	border: 3px solid #d5001a;
    }
    .write-block {
      margin-top: 18px;
      margin-bottom: 10px;
    }
    .write-block textarea {
      width: 100%;
      min-height: 100px;
      font-size: 1.2em;
      border-radius: 8px;
      border: 1px solid #adc9ff;
      background: #f9faff;
      padding: 7px 10px;
      resize: none;
      margin-bottom: 7px;
      font-family: inherit;
      transition: border 0.15s;
      overflow-y: hidden;
      box-sizing: border-box;
      user-select: none;
    }
    .write-block textarea:focus {
      outline: 2px solid #7a9afd;
      border-color: #7a9afd;
    }
    .send-btn {
      user-select: none;
      background: linear-gradient(90deg, #7a9afd 0%, #4f79e7 100%);
      color: #fff;
      border: none;
      border-radius: 7px;
      padding: 8px 24px;
      font-size: 1em;
      font-weight: 500;
      cursor: pointer;
      box-shadow: 0 2px 8px #adc9ff22;
      transition: background 0.16s;
      margin-bottom: 10px;
      margin-top: 4px;
      display: inline-block;
    }
    .send-btn:hover {
      background: linear-gradient(90deg, #4f79e7 0%, #7a9afd 100%);
    }
    .self-eval-block {
      margin-top: 6px;
      display: flex;
      flex-direction: row;
      gap: 4px;
      align-items: center;
      font-size: 1.01em;
      flex-wrap: wrap;
    }
    .self-eval-label {
      font-weight: 500;
      color: #445;
      margin-right: 8px;
	  user-select: none;
    }
    .self-eval-btn {
      border: 1.5px solid #adc9ff;
      background: #ecf4fe;
      color: #4b53b7;
      border-radius: 5px;
      font-size: 1.08em;
      padding: 4px 13px;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.14s, border 0.14s, color 0.14s;
      margin-left: 0;
      margin-right: 0;
	  user-select: none;
    }
    .self-eval-btn.selected,
    .self-eval-btn:hover {
      background: #7a9afd;
      color: #fff;
      border-color: #4f79e7;
    }
    #submitAll {
      display: none;
      user-select: none;
      margin-top: 10px;
      background: linear-gradient(90deg, #7a9afd 0%, #4f79e7 100%);
      color: #fff;
      border: none;
      border-radius: 9px;
      padding: 12px 32px;
      font-size: 1.12em;
      font-weight: 500;
      cursor: pointer;
      box-shadow: 0 2px 10px #a8b7ee33;
      transition: background 0.16s, box-shadow 0.16s;
      margin-left: 50%;
      transform: translateX(-50%);
    }
    #submitAll:hover {
      background: linear-gradient(90deg, #4f79e7 0%, #7a9afd 100%);
      box-shadow: 0 4px 18px #7a9afd33;
    }
    #score {
      font-size: 1.18em;
      font-weight: 600;
      text-align: center;
      margin-top: 28px;
      color: #373853;
      letter-spacing: 1px;
      background: #f1f5ff;
      border-radius: 10px;
      padding: 16px 0 14px 0;
      border: 1px solid #d3e1fa;
      box-shadow: 0 1px 8px #adc9ff22;
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
      white-space: pre-line;
    }
    @media (max-width: 700px) {
      #container { padding: 16px 2vw 12px 2vw; }
      .question-block { padding: 12px 3vw 10px 3vw; }
    }
    #quiz img {
      display: block;
      margin: 16px auto;
      max-width: 90%;
      max-height: 70vh;
      border-radius: 12px;
      cursor: zoom-in;
    }
    #imgModal {
      display: none;
      position: fixed;
      z-index: 10000;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.8);
      justify-content: center;
      align-items: center;
    }
    #imgModal.open {
      display: flex;
    }
    #imgModal img {
      margin: 10px auto 100px;
      width: auto;
      height: auto;
      max-width: 60%;
      max-height: 60%;
      transform: scale(1.5);
      transform-origin: center center;
      box-shadow: 0 0 24px #0008;
    }
    input[type="file"] {
      user-select: none;
    }
    input[type="file"]::file-selector-button,
    input[type="file"]::-webkit-file-upload-button {
      user-select: none;
    }
    input[type="file"]::-moz-file-upload-text {
      user-select: none;
    }
    input[type="file"]::-webkit-file-upload-text {
      user-select: none;
    }
    .escrita-item-label {
      font-size: 1.2em;
      margin-bottom: 2px;
      display: block;
      user-select: text;
    }
	#score-table-container {
	  max-width: 480px;
	  margin: 36px auto 8px auto;
	  border-radius: 14px;
	  background: #f8fbff;
	  box-shadow: 0 2px 12px #7a9afd18, 0 1px 4px #aac1f933;
	  border: 1.5px solid #a6c8ff22;
	  padding: 24px 24px 18px 24px;
	  text-align: center;
	}
	.score-title {
	  font-size: 1.25em;
	  font-weight: 600;
	  color: #2e3d63;
	  margin-bottom: 7px;
	  letter-spacing: 0.5px;
	  user-select: none;
	}
	#score-table {
	  width: 96%;
	  border-collapse: collapse;
	  margin: 0 auto 8px auto;
	  background: none;
	  font-size: 1.10em;
	}
	#score-table th, #score-table td {
	  padding: 7px 10px;
	  border: none;
	}
	#score-table th {
	  color: #4661a5;
	  font-weight: 500;
	  font-size: 1em;
	  background: none;
	}
	#score-table tr {
	  border-bottom: 1px solid #dde6fa;
	}
	#score-table tr:last-child {
	  border-bottom: none;
	}
	#score-table td {
	  color: #24324d;
	  font-size: 1.11em;
	}
	.score-type {
	  font-weight: 500;
	  color: #384871;
	  background: none;
	}
	.score-note {
	  font-weight: 600;
	  color: #247fc5;
	}
	.score-detail {
	  color: #576b95;
	  font-size: 0.97em;
	}
	#score-overall-row td {
	  font-size: 1.21em;
	  font-weight: 800;
	  color: #238969;
	  background: linear-gradient(90deg,#e7fff4 0%,#d2f8fa 100%);
	  border-radius: 7px;
	  border-bottom: none !important;
	  letter-spacing: 0.5px;
	  box-shadow: 0 1px 8px #6ee0bc15;
	}
	@media (max-width:600px) {
	  #score-table-container { padding: 14px 3vw 8px 3vw; }
	  #score-table { font-size: 1em; }
	  #score-overall-row td { font-size: 1.09em;}
	}
	/* --- Linhas de Conexão em Árvore --- */

	/* Ajusta as listas aninhadas para dar espaço às linhas */
	.cloud-quiz-list .folder > ul {
	  position: relative;
	  padding-left: 25px; /* Espaço à esquerda para as linhas */
	  margin-left: 5px;
	}

	/* Desenha a linha VERTICAL principal que desce da pasta */
	.cloud-quiz-list .folder > ul::before {
	  content: '';
	  position: absolute;
	  left: 0;
	  top: -6px; /* Ajuste para conectar na pasta-pai */
	  width: 1px;
	  height: 100%;
	  background: #c6d7ee; /* Cor suave para a linha */
	}

	/* Prepara cada item da lista para receber sua linha de conexão */
	.cloud-quiz-list .folder > ul > li {
	  position: relative;
	}

	/* Desenha a linha HORIZONTAL (o "traço" do "├") para cada item */
	.cloud-quiz-list .folder > ul > li::before {
	  content: '';
	  position: absolute;
	  left: -25px; /* Puxa a linha para a área do padding */
	  top: 16px;   /* Alinhamento vertical da linha. Ajuste se necessário */
	  width: 25px;
	  height: 1px;
	  background: #c6d7ee;
	}

	/* Truque para o ÚLTIMO item da lista: apaga a linha vertical para criar o "└" */
	.cloud-quiz-list .folder > ul > li:last-child::after {
	  content: '';
	  position: absolute;
	  left: 0px;
	  top: 17px; /* Posição para começar a "apagar" */
	  width: 1px;
	  height: 100%;
	  background: #f9fcff; /* Cor de fundo da lista, para "esconder" a linha vertical */
	}
	/* --- Ajuste Fino de Alinhamento para Subpastas --- */

	/* Move a linha de conexão para CIMA quando o item é uma SUBPASTA */
	.cloud-quiz-list .folder > ul > li.folder::before {
	  top: 12px; /* Valor menor para alinhar ao centro do texto da pasta */
	}

	/* Ajusta o "corte" da linha para o caso de o ÚLTIMO item ser também uma SUBPASTA */
	.cloud-quiz-list .folder > ul > li.folder:last-child::after {
	  top: 13px; /* Posição correspondente para iniciar o "corte" */
	}
  /* Adicione estas regras ao seu CSS existente */

	.folder.collapsed > ul {
	  display: none;
	}
	.folder.collapsed > ul::before, /* Esconde a linha vertical principal da pasta recolhida */
	.folder.collapsed > ul > li::before { /* Esconde as linhas horizontais dos itens */
		display: none;
	}

	.folder-name {
	  cursor: pointer;
	  font-weight: bold;
	  padding: 4px 2px;
	  display: inline-block; /* Permite que o padding funcione corretamente */
	  transition: background-color 0.15s;
	  border-radius: 4px;
	}
	.folder-name:hover {
	  background-color: #e9f3ff;
	}
  </style>
</head>
<body>
<div id="container">
  <h1>Questões do Terceiro Período</h1>
  <div class="tutorial">
    <strong>Como usar:</strong><br>
    1. Importe o arquivo <strong>TXT</strong> contendo o quiz ou escolha um dos Quizes da Nuvem abaixo.<br>
    2. Por padrão, as opções <strong>aleatorizar questões</strong> e <strong>aleatorizar alternativas</strong> já estão marcadas.<br>
    3. Se preferir, <u>desmarque</u> essas opções para responder ao quiz na ordem original.<br>
    4. Clique em <b>Resetar Quiz</b> para reiniciar seu progresso com o quiz atual.<br>
    5. <b>Dica:</b> Nas questões de múltipla escolha e de checkbox, utilize o botão <span style="border-radius:50%;border:1.5px solid #c6d7ee;background:#eef2f6;padding:2px 5px;">✂️</span> ao lado de cada alternativa para "eliminar" opções que você não quer marcar.<br>
    6. <b>Mesclar quiz:</b> Após clicar em "quizes da nuvem", você pode opcionalmente clicar em "mesclar quiz" para criar um quiz customizável que junta todas as questões dos quizes que você selecionar.<br><br>
	<em>O quiz pode conter questões de múltipla escolha, V ou F (inclusive com variantes), checkbox e questões abertas (escrita).</em>
  </div>
  <div id="imgModal" onclick="closeImageModal()">
    <img id="imgModalImg" src="" alt="Clique para fechar">
  </div>
  <button class="cloud-quiz-btn" type="button" id="cloudQuizBtn">Quizes da Nuvem</button>
  <div id="cloudQuizList" class="cloud-quiz-list" style="display:none"></div>
  <input type="file" id="fileInput" accept=".txt" />
  <div class="options-bar">
    <label><input type="checkbox" id="shuffleQuestions" checked> Aleatorizar questões</label>
    <label><input type="checkbox" id="shuffleAlternatives" checked> Aleatorizar alternativas (apenas múltipla escolha e checkbox)</label>
    <button id="resetQuizBtn" type="button">Resetar Quiz</button>
  </div>
  <div id="quizTitle" style="text-align:center; font-size:1.5em; font-weight:600; color:#305;"></div><br>
  <div id="quiz"></div>
  <button id="submitAll">Enviar Todas as Respostas/Ver Nota Final</button>
  <div id="score"></div>
</div>

<script>
/* -------------------------  VARIÁVEIS GLOBAIS  ------------------------- */
let cloudQuizData = null;
let shuffleQuestionsLocked = false;
let currentQuizTitle = "";
let isMergeMode = false;
let selectedForMerge = []; 

function renderQuizTitle() {
  <!-- document.getElementById('quizTitle').innerHTML = currentQuizTitle ? currentQuizTitle : ""; -->
}


fetch('quizes.json?v=' + Date.now())
  .then((response) => response.json())
  .then((data) => { cloudQuizData = data; })
  .catch((err) => console.error('Erro ao carregar quizes.json:', err));

/* ----------  NOVO  ----------  seleções dos variantes escolhidos */
let variantSelections = [];   // índices escolhidos para cada questão do tipo vf‑variante

/* ------------------  RENDERIZA LISTA DE QUIZ NA NUVEM  ----------------- */
function renderCloudQuizList(tree) {
  function removeExtension(name) {
    return name.replace(/\.txt$/i, "");
  }
  function renderNode(node) {
    if (node.type === 'file') {
      if (isMergeMode) {
        return `<li>
                  <label style="cursor:pointer; display:flex; align-items:center; padding: 4px 0;">
                    <input type="checkbox" class="merge-checkbox" 
                           data-path="${node.path}" 
                           data-name="${removeExtension(node.name)}" 
                           style="margin-right: 8px; transform: scale(1.1);">
                    <span class="alt-text-content">${removeExtension(node.name)}</span>
                  </label>
                </li>`;
      } else {
        return `<li><button class="quiz-link" data-path="${node.path}">${removeExtension(node.name)}</button></li>`;
      }
    } else if (node.type === 'folder') {
      // --- ALTERAÇÕES AQUI ---
      // 1. Adiciona a classe "collapsed" por padrão.
      // 2. Envolve o nome da pasta em um <span class="folder-name"> para ser clicável.
      return `<li class="folder collapsed">
                <span class="folder-name">${node.name}</span>
                <ul>${node.children.map(renderNode).join("")}</ul>
              </li>`;
    }
    return "";
  }
  return `<ul>${tree.map(renderNode).join("")}</ul>`;
}
const cloudQuizBtn   = document.getElementById('cloudQuizBtn');
const cloudQuizListDiv = document.getElementById('cloudQuizList');
cloudQuizBtn.addEventListener('click', () => {
  if (cloudQuizListDiv.style.display === 'none') {
    // Apenas cria os controles na primeira vez que o painel é aberto
    if (!document.getElementById('merge-controls')) {
      const controlsDiv = document.createElement('div');
      controlsDiv.id = 'merge-controls';
      controlsDiv.style.paddingBottom = '15px';
      controlsDiv.style.borderBottom = '1px solid #dde6fa';
      controlsDiv.style.marginBottom = '10px';
      controlsDiv.innerHTML = `
        <button id="toggleMergeModeBtn" class="cloud-quiz-btn">Mesclar Quizes</button>
        <button id="createMergedQuizBtn" class="cloud-quiz-btn" style="display:none; background: linear-gradient(90deg, #6d84f0 0%, #99aaff 100%);">Criar Quiz Mesclado</button>
        
        <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #eef2f6;">
          <label style="cursor:pointer; font-size: 0.95em; color: #324a78; user-select: none;">
            <input type="checkbox" id="expandAllFoldersCb" style="margin-right: 5px; vertical-align: middle;">
            Expandir todas as pastas
          </label>
        </div>
      `;
      cloudQuizListDiv.prepend(controlsDiv);

      // Listener do botão "Mesclar Quizes"
      document.getElementById('toggleMergeModeBtn').addEventListener('click', (e) => {
        isMergeMode = !isMergeMode;
        selectedForMerge = [];
        e.target.textContent = isMergeMode ? 'Cancelar Mesclagem' : 'Mesclar Quizes';
        e.target.style.background = isMergeMode ? 'linear-gradient(90deg, #f09a6d 0%, #ffc699 100%)' : '';
        document.getElementById('createMergedQuizBtn').style.display = 'none';
        if (cloudQuizData) {
            const listContainer = cloudQuizListDiv.querySelector('ul');
            if(listContainer) listContainer.outerHTML = renderCloudQuizList(cloudQuizData);
        }
      });

      // Listener do botão "Criar Quiz Mesclado"
      document.getElementById('createMergedQuizBtn').addEventListener('click', async () => {
        if (selectedForMerge.length < 2) return;
        const btn = document.getElementById('createMergedQuizBtn');
        btn.textContent = 'Carregando...';
        btn.disabled = true;
        try {
          const fetchPromises = selectedForMerge.map(quiz => fetch(quiz.path).then(res => res.text()));
          const allTexts = await Promise.all(fetchPromises);
          const mergedText = allTexts.join('\n\n---\n\n');
          const quizListHtml = selectedForMerge.map(q => q.name).join('<br>+<br>');
          currentQuizTitle = `Quiz mesclado:<br><br>${quizListHtml}`;
          processQuizText(mergedText);
          renderQuizTitle();
          cloudQuizListDiv.style.display = 'none';
		  document.getElementById('expandAllFoldersCb').checked = false;
          isMergeMode = false;
		  document.getElementById('toggleMergeModeBtn').textContent = 'Mesclar Quizes';
          document.getElementById('toggleMergeModeBtn').style.background = '';
          btn.style.display = 'none';
        } catch (error) {
          console.error("Erro ao mesclar os quizes:", error);
          alert("Ocorreu um erro ao buscar os arquivos do quiz. Verifique o console.");
        } finally {
            btn.textContent = 'Criar Quiz Mesclado';
            btn.disabled = false;
        }
      });

      // NOVO LISTENER PARA O CHECKBOX 'EXPANDIR TODAS'
      document.getElementById('expandAllFoldersCb').addEventListener('change', function(e) {
        const allFolders = cloudQuizListDiv.querySelectorAll('li.folder');
        const shouldExpand = e.target.checked;
        allFolders.forEach(folder => {
            if (shouldExpand) {
                folder.classList.remove('collapsed');
            } else {
                folder.classList.add('collapsed');
            }
        });
      });
    }

    if (cloudQuizData) {
      const listContainer = cloudQuizListDiv.querySelector('ul');
      if(listContainer) {
          listContainer.outerHTML = renderCloudQuizList(cloudQuizData);
      } else { 
          cloudQuizListDiv.insertAdjacentHTML('beforeend', renderCloudQuizList(cloudQuizData));
      }
    } else {
      cloudQuizListDiv.innerHTML = "Carregando lista de quizzes...";
    }
    cloudQuizListDiv.style.display = 'block';
  } else {
    cloudQuizListDiv.style.display = 'none';
	document.getElementById('expandAllFoldersCb').checked = false;
  }
});


// SUBSTITUA ESTE BLOCO INTEIRO
cloudQuizListDiv.addEventListener('click', (e) => {
  // --- Comportamento do link de quiz (botão) ---
  if (e.target.classList.contains('quiz-link')) {
    if (isMergeMode) return; 

    const quizPath = e.target.getAttribute('data-path');
    currentQuizTitle = e.target.textContent || "";
    fetch(quizPath)
      .then((res) => res.text())
      .then((text) => {
        processQuizText(text);
        renderQuizTitle();
      });
    cloudQuizListDiv.style.display = 'none';
	document.getElementById('expandAllFoldersCb').checked = false;
  }

  // --- Comportamento do checkbox de mesclagem (já existe) ---
  if (e.target.classList.contains('merge-checkbox')) {
    const path = e.target.dataset.path;
    const name = e.target.dataset.name;

    if (e.target.checked) {
      selectedForMerge.push({ path, name });
    } else {
      selectedForMerge = selectedForMerge.filter(q => q.path !== path);
    }
    
    document.getElementById('createMergedQuizBtn').style.display = selectedForMerge.length >= 2 ? 'inline-block' : 'none';
  }

  // --- NOVO: Lógica para expandir/recolher uma pasta individual ---
  if (e.target.classList.contains('folder-name')) {
    const folderLi = e.target.closest('li.folder');
    if (folderLi) {
      folderLi.classList.toggle('collapsed');
    }
  }
});



/* ---------------   INPUT, CHECKBOXES, BOTÕES GLOBAIS   ----------------- */
const fileInput               = document.getElementById('fileInput');
const shuffleQuestionsChk     = document.getElementById('shuffleQuestions');
const shuffleAlternativesChk  = document.getElementById('shuffleAlternatives');
const resetQuizBtn            = document.getElementById('resetQuizBtn');

/* -------------------  ESTRUTURAS DE DADOS PRINCIPAIS  ------------------ */
let originalQuestions           = [];
let questions                   = [];
let userAnswers                 = [];
let tempAnswers                 = [];
let scoreME = 0, scoreVF = 0, scoreCheck = 0, scoreEscrita = 0;
let shuffledQuestionsOrder      = [];
let shuffledAlternativesOrders  = [];
let shuffledCheckboxOrders      = [];
let escritaAutoNotas            = [];
let escritaItensAutoNotas       = []; // dissertativas por item
let escritaItensRespostas       = [];
let quizTextHash                = "";
let groups                      = [];

/* -------------------  EXTRAÇÃO DE GRUPOS (juntas + variantes ou qualquer tipo)  ------------------ */
function extractGroupsAndParse(text) {
  const juntasRegex = /<juntas>([\s\S]*?)<\/juntas>/gi;
  let allQs = [];
  let groups = [];
  let lastEnd = 0;
  let mJ;

  // 1) percorre cada bloco <juntas>…</juntas>
  while ((mJ = juntasRegex.exec(text)) !== null) {
    // tudo que vem antes de <juntas>
    const before = text.slice(lastEnd, mJ.index).trim();
    if (before) {
      allQs.push(... parsePlainOrVariantes(before));
    }

    // parse genérico de tudo dentro de <juntas>
    const innerBlock = mJ[1];
    const groupStart = allQs.length;
    const innerQs    = parsePlainOrVariantes(innerBlock);

    allQs.push(... innerQs);
    if (innerQs.length >= 1) {
      // garante que todos fiquem juntos
      groups.push({ start: groupStart, length: innerQs.length });
    }

    lastEnd = juntasRegex.lastIndex;
  }

  // 2) resto após o último </juntas>
  const tail = text.slice(lastEnd).trim();
  if (tail) {
    allQs.push(... parsePlainOrVariantes(tail));
  }

  return { originalQuestions: allQs, groups };
}

/* auxiliar que trata tanto blocos <variantes> isolados quanto perguntas comuns */
function parsePlainOrVariantes(chunk) {
  let res = [];
  const varRegex = /<variantes>([\s\S]*?)<\/variantes>/gi;
  let last = 0, mv;

  while ((mv = varRegex.exec(chunk)) !== null) {
    // antes de cada <variantes>
    const antes = chunk.slice(last, mv.index).trim();
    if (antes) {
      res.push(... parseQuestions(antes));
    }
    // transforma o bloco de variantes em UMA pergunta tipo vf-variante
    const variantes = parseQuestions(mv[1]).map(v => ({
      enunciado:  v.enunciado,
      gabarito:   v.gabarito,
      comentario: v.comentario || null
    }));
    res.push({ tipo: 'vf-variante', variantes });
    last = varRegex.lastIndex;
  }

  // o que sobrou depois do último </variantes>
  const resto = chunk.slice(last).trim();
  if (resto) {
    res.push(... parseQuestions(resto));
  }

  return res;
}


/* -----------------------------  PROCESSA TXT  ---------------------------- */
function processQuizText(fileText) {
  shuffleQuestionsLocked = false;
  const extracted  = extractGroupsAndParse(fileText);
  originalQuestions = extracted.originalQuestions;
  groups            = extracted.groups;

  /* trata flag q-random:false */
  const lines = fileText.split(/\r?\n/);
  if (lines.length && /^q-random:\s*false;?/i.test(lines[0].trim())) {
    shuffleQuestionsLocked   = true;
    shuffleQuestionsChk.checked  = false;
    shuffleQuestionsChk.disabled = true;
    shuffleQuestionsChk.parentElement.style.opacity = 0.6;
    lines.shift();
    fileText = lines.join("\n");
  } else {
    shuffleQuestionsChk.disabled = false;
    shuffleQuestionsChk.parentElement.style.opacity = 1;
  }

  quizTextHash = simpleHash(fileText);

  /* reinicia variáveis de sessão */
  shuffledQuestionsOrder = [];
  shuffledAlternativesOrders = [];
  shuffledCheckboxOrders = [];
  variantSelections = [];                          // <<<
  userAnswers = [];
  tempAnswers  = [];
  scoreME = scoreVF = scoreCheck = scoreEscrita = 0;
  escritaAutoNotas       = [];
  escritaItensAutoNotas  = [];
  escritaItensRespostas  = [];

  setupQuiz();
  saveCurrentState(fileText);
}

/* -------------------   HASH SIMPLES PARA CACHE   -------------------- */
function simpleHash(str) {
  let hash = 0, i, chr;
  if (str.length === 0) return hash.toString();
  for (i = 0; i < str.length; i++) {
    chr = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + chr;
    hash |= 0;
  }
  return hash.toString();
}

/* --------------------  CARREGA ESTADO SALVO NO ONLOAD  ------------------ */
window.addEventListener("DOMContentLoaded", function() {
  const state = loadState();
  if (state && state.quizText && state.quizTextHash) {
    let fileText = state.quizText;

    shuffleQuestionsLocked = !!state.shuffleQuestionsLocked;
    if (shuffleQuestionsLocked) {
      shuffleQuestionsChk.checked  = false;
      shuffleQuestionsChk.disabled = true;
      shuffleQuestionsChk.parentElement.style.opacity = 0.6;
    } else {
      shuffleQuestionsChk.disabled = false;
      shuffleQuestionsChk.parentElement.style.opacity = 1;
    }

    /* compat antigo q-random:false */
    const lines = fileText.split(/\r?\n/);
    if (!shuffleQuestionsLocked && lines.length && /^q-random:\s*false;?/i.test(lines[0].trim())) {
      shuffleQuestionsLocked   = true;
      shuffleQuestionsChk.checked  = false;
      shuffleQuestionsChk.disabled = true;
      shuffleQuestionsChk.parentElement.style.opacity = 0.6;
      lines.shift();
      fileText = lines.join("\n");
    }

    const extracted = extractGroupsAndParse(fileText);
    const parsed    = extracted.originalQuestions;
    if (parsed.length) {
      originalQuestions = parsed;
      groups            = extracted.groups;
      quizTextHash      = state.quizTextHash;
      shuffledQuestionsOrder   = state.shuffledQuestionsOrder   || [...Array(parsed.length).keys()];
      shuffledAlternativesOrders = state.shuffledAlternativesOrders || [];
      shuffledCheckboxOrders  = state.shuffledCheckboxOrders  || [];
      variantSelections       = state.variantSelections       || [];
      questions               = shuffledQuestionsOrder.map(idx => originalQuestions[idx]);
      // Restaura respostas gerais
userAnswers = state.userAnswers || Array(questions.length).fill(null);

// Corrige DISERTATIVAS-ITENS: se não houver respostas enviadas, garanta undefined por item
questions.forEach((q, idx) => {
  if (q.tipo === 'escrita-itens') {
    // Se state.userAnswers[idx] não for array com itens realmente respondidos...
    if (!state.userAnswers 
        || !Array.isArray(state.userAnswers[idx]) 
        || state.userAnswers[idx].every(v => v === null)) {
      // inicializa cada sub-resposta como undefined, não como null
      userAnswers[idx] = Array(q.itens.length).fill(undefined);
    }
  }
});

      // Restaura respostas temporárias gerais
tempAnswers = state.tempAnswers || Array(questions.length).fill(null);


escritaAutoNotas        = state.escritaAutoNotas        || [];
escritaItensAutoNotas   = state.escritaItensAutoNotas   || [];

// Corrige escrita-itens: converte nulls para undefined em userAnswers e escritaItensAutoNotas
questions.forEach((q, idx) => {
  if (q.tipo === 'escrita-itens') {
    // Corrige respostas dos itens
    if (state.userAnswers && Array.isArray(state.userAnswers[idx])) {
      userAnswers[idx] = state.userAnswers[idx].map(val => val === null ? undefined : val);
    } else {
      userAnswers[idx] = Array(q.itens.length).fill(undefined);
    }
    // Corrige autoavaliação dos itens
    if (state.escritaItensAutoNotas && Array.isArray(state.escritaItensAutoNotas[idx])) {
      escritaItensAutoNotas[idx] = state.escritaItensAutoNotas[idx].map(val => val === null ? undefined : val);
    } else {
      escritaItensAutoNotas[idx] = Array(q.itens.length).fill(undefined);
    }
  }
});

escritaItensRespostas   = state.escritaItensRespostas   || [];
scoreME   = state.scoreME   || 0;
scoreVF   = state.scoreVF   || 0;
scoreCheck= state.scoreCheck|| 0;
scoreEscrita = state.scoreEscrita || 0;
shuffleQuestionsChk.checked     = !!state.shuffleQuestions;
shuffleAlternativesChk.checked  = !!state.shuffleAlternatives;
currentQuizTitle = state.currentQuizTitle || "";
window.individualScores = state.individualScores || { me: [], vf: [], check: [] };

renderQuizTitle();
document.getElementById('score').textContent = '';
renderQuiz();
return;
    }
  }
});

/* ---------------------  INPUT DE ARQUIVO LOCAL  ----------------------- */
fileInput.addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(ev) {
    currentQuizTitle = file.name.replace(/\.txt$/i, "");
    processQuizText(ev.target.result);
    renderQuizTitle();
  };
  reader.readAsText(file, 'utf-8');
});


/* ---------------------------  RESET QUIZ  --------------------------- */
resetQuizBtn.addEventListener('click', function() {
  if (!originalQuestions.length) return;
  variantSelections = [];     // força escolher novos variantes
  setupQuiz();
  renderQuizTitle();
  saveCurrentState();
});
shuffleQuestionsChk.addEventListener('change', function() {
  if (shuffleQuestionsLocked) {
    shuffleQuestionsChk.checked = false;
    return;
  }
  setupQuiz();
  saveCurrentState();
});
shuffleAlternativesChk.addEventListener('change', function() {
  setupQuiz();
  saveCurrentState();
});

/* --------------------------   SETUP QUIZ   --------------------------- */
function setupQuiz() {
  if (!originalQuestions.length) {
    document.getElementById('quiz').innerHTML =
      "<div style='text-align:center;color:#b22;font-size:1.1em;font-weight:600'>Nenhuma questão válida encontrada.<br>Verifique o formato do arquivo.</div>";
    document.getElementById('submitAll').style.display = 'none';
    document.getElementById('score').textContent = '';
    return;
  }
  const n = originalQuestions.length;

  /*  Escolha (ou preserva) variante para cada questão vf‑variante  */
  for (let i = 0; i < n; i++) {
    const q = originalQuestions[i];
    if (q.tipo === 'vf-variante') {
        // Garantir que variantSelections tenha o tamanho certo, preenchendo com null se necessário
        while (variantSelections.length <= i) {
            variantSelections.push(null);
        }
        // Escolher apenas se for null ou undefined
        if (variantSelections[i] === undefined || variantSelections[i] === null) {
            variantSelections[i] = Math.floor(Math.random() * q.variantes.length);
        }
    } else {
        // Adicionar null para outros tipos de questão para manter o índice alinhado
         while (variantSelections.length <= i) {
            variantSelections.push(null);
        }
    }
  }


  /*  ----------  randomização / manutenção de grupos  --------- */
  if (shuffleQuestionsChk.checked) {
    const allIdx   = [...Array(n).keys()];
    const movable  = allIdx.filter(i =>
      !groups.some(g => i >= g.start && i < g.start + g.length)
    );
    const shuffledMovable = shuffleArray(movable);

    let result = [];
    let movPtr = 0;
    for (let pos = 0; pos < n; pos++) {
      const grp = groups.find(g => g.start === pos);
      if (grp) {
        for (let k = 0; k < grp.length; k++) result.push(pos + k);
        pos += grp.length - 1;
      } else {
        if (movPtr < shuffledMovable.length) { // Check bounds
           result.push(shuffledMovable[movPtr++]);
        } else {
            // This case shouldn't happen if logic is correct, but as a fallback:
            // Find the next index not already in result and not part of a group that hasn't started
            let fallbackIndex = -1;
            for (let potentialIdx = 0; potentialIdx < n; potentialIdx++) {
                if (!result.includes(potentialIdx) && !groups.some(g => potentialIdx >= g.start && potentialIdx < g.start + g.length && !result.includes(g.start))) {
                    fallbackIndex = potentialIdx;
                    break;
                }
            }
            if(fallbackIndex !== -1) result.push(fallbackIndex);
             // else console.error("Could not find a fallback index for shuffling");
        }
      }
    }
    shuffledQuestionsOrder = result;
  } else {
    shuffledQuestionsOrder = [...Array(n).keys()];
  }

  /*  ----------  randomização de alternativas/check‑box  ---------- */
  shuffledAlternativesOrders = [];
  shuffledCheckboxOrders = [];
  for (let qidx = 0; qidx < originalQuestions.length; qidx++) {
    const q = originalQuestions[qidx];
    if (q.tipo === 'me') {
      const alts = q.alternativas.map(a => a.letra);
      shuffledAlternativesOrders[qidx] = shuffleAlternativesChk.checked ? shuffleArray(alts) : alts;
      shuffledCheckboxOrders[qidx]     = null;
    }
    else if (q.tipo === 'checkbox') {
      const nAssert = q.assertives.length;
      const arrIdx  = [...Array(nAssert).keys()];
      shuffledCheckboxOrders[qidx] = (shuffleAlternativesChk.checked && !q.noRandom) ? shuffleArray(arrIdx) : arrIdx;
      shuffledAlternativesOrders[qidx] = null;
    }
    else {
      shuffledAlternativesOrders[qidx] = null;
      shuffledCheckboxOrders[qidx]     = null;
    }
  }

  questions      = shuffledQuestionsOrder.map(idx => originalQuestions[idx]);
  userAnswers    = Array(questions.length).fill(null);
  tempAnswers    = Array(questions.length).fill(null);
  escritaAutoNotas       = Array(questions.length).fill(null);
  escritaItensAutoNotas  = Array(questions.length).fill(null);
  escritaItensRespostas  = Array(questions.length).fill(null);
  scoreME = scoreVF = scoreCheck = scoreEscrita = 0;
  document.getElementById('score').textContent = '';
  renderQuiz();
  // Don't save state here yet, let the caller (processQuizText or button clicks) handle saving
  // saveCurrentState(); // Removed from here
}


/* -------------------  PARSER DE QUESTÕES (Copied from V1)  ------------------- */
function parseQuestions(text) {
  const blocks = text.split(/\n\s*\n|^-{3,}$/m)
    .map(b => b.trim())
    .filter(Boolean);
  const questions = [];
  for (const block of blocks) {
    // Checkbox (QCH:) - Abordagem v4: Separar enunciado e assertivas
    const inicioCheckboxMatch = block.match(/^QCH:\s*/i); // Encontra apenas o início
    if (inicioCheckboxMatch) {
        // Encontra onde as assertivas começam
        const inicioAssertivasRegex = /(?:^\s*A\d+:|^\s*NO-RANDOM:)/im; // Adiciona 'm' para ^ funcionar por linha
        const matchInicioAssertivas = inicioAssertivasRegex.exec(block);

        let enunciado = "";
        let textoAssertivas = "";
        const indiceInicioQCH = inicioCheckboxMatch[0].length; // Posição após "QCH: "

        if (matchInicioAssertivas) {
            // Separa o enunciado (do fim de QCH: até o início das assertivas)
            enunciado = block.substring(indiceInicioQCH, matchInicioAssertivas.index).trim();
            // Separa o texto que contém apenas as assertivas e NO-RANDOM
            textoAssertivas = block.substring(matchInicioAssertivas.index);
        } else {
            // Não encontrou assertivas nem NO-RANDOM, bloco inteiro é enunciado? (Pouco provável para QCH válido)
            enunciado = block.substring(indiceInicioQCH).trim();
            textoAssertivas = ""; // Nenhuma assertiva para processar
            // console.warn("Questão QCH detectada mas sem assertivas (A:) ou NO-RANDOM: encontradas."); // Optional warning
        }

        const enunciadoFormatado = autoEmbedImages(enunciado); // Formata só o enunciado
        const noRandom = /^\s*NO-RANDOM:\s*TRUE/i.test(textoAssertivas); // Verifica NO-RANDOM no início do texto das assertivas

        const assertives = [];
        const assertiveRegex = /A(\d{1,2}):\s*([\s\S]+?)(?:^G:\s*([VF])\s*(?:\n|$))((?:\s*C:\s*((?:(?!\s*^A\d+:|\s*^NO-RANDOM:)[\s\S])+))?(?=^A\d+:|^NO-RANDOM:|$))/gmi; // Regex da v3 (bom para assertivas)

        // *** IMPORTANTE: Execute o regex no texto *separado* das assertivas ***
        let match;
        let count = 0;
        // Reset lastIndex before executing regex in a loop
        assertiveRegex.lastIndex = 0;
        while ((match = assertiveRegex.exec(textoAssertivas)) !== null && count < 50) {
             // Check if match[2] is just whitespace or empty, skip if so
            if (!match[2] || /^\s*$/.test(match[2])) continue;
            assertives.push({
                idx: count, // Use count as index
                texto: autoEmbedImages(match[2].trim()),
                gabarito: match[3],
                comentario: match[5] ? autoEmbedImages(match[5].trim()) : null,
            });
            count++;
        }


        if (assertives.length > 0) {
            questions.push({
                tipo: 'checkbox',
                enunciado: enunciadoFormatado, // Usa o enunciado separado e formatado
                assertives,
                noRandom
            });
            continue; // Próximo bloco
        } else if (!textoAssertivas && enunciado) {
             // If no valid assertives but had an enunciado, let it try other types
             // console.log("Bloco começou com QCH: mas não teve assertivas válidas. Tentando outros tipos.");
        }
    }
    // NOVO: Dissertativa com itens
    const escritaItensMatch = block.match(/^Q:\s*([\s\S]+?)(?=^I_[A-Z]\))/m);
    if (escritaItensMatch) {
      const enunciado = autoEmbedImages(escritaItensMatch[1].trim());
      // Extrair itens: I_A) ... GABARITO: ... (até 26)
      const itens = [];
      const itemRegex = /^I_([A-Z])\)\s*([\s\S]+?)^\s*GABARITO:\s*((?:(?!\s*^I_[A-Z]\))[\s\S])+)/gm;
      let match, count = 0;
       itemRegex.lastIndex = 0; // Reset lastIndex
      while ((match = itemRegex.exec(block)) !== null && count < 26) {
        itens.push({
          letra: match[1],
          texto: autoEmbedImages(match[2].trim()),
          gabarito: match[3].trim()
        });
        count++;
      }
      if (itens.length > 0) {
        questions.push({
          tipo: 'escrita-itens',
          enunciado,
          itens
        });
        continue;
      }
    }
    // Questão discursiva tradicional
    const openQ = block.match(/^Q:\s*([\s\S]+?)^\s*GABARITO:\s*([\s\S]+)$/m);
    if (openQ) {
      const enunciado = autoEmbedImages(openQ[1].trim());
      questions.push({
        tipo: 'escrita',
        enunciado,
        gabarito: openQ[2].trim()
      });
      continue;
    }
    // Múltipla escolha e VF
    const qMatch = block.match(/^Q:\s*([\s\S]+?)(?=^([A-E]\)|G:))/m);
    if (!qMatch) continue;
    const enunciado = autoEmbedImages(qMatch[1].trim());
    const gMatch = block.match(/^G:\s*([A-EVF])$/m);
    if (!gMatch) continue;
    const gabarito = gMatch[1];
    const cmtMatch = block.match(/^C:\s*([\s\S]+)$/m);
    const comentario = cmtMatch ? autoEmbedImages(cmtMatch[1].trim()) : null;
    const altRegex = /^([A-E])\)\s*([\s\S]+?)(?=^[A-E]\)|^G:|^C:|^$)/gm;
    const alternativas = [];
    let mAlt;
    altRegex.lastIndex = 0; // Reset lastIndex
    while ((mAlt = altRegex.exec(block)) !== null) {
      alternativas.push({
        letra: mAlt[1],
        texto: mAlt[2].trim()
      });
    }
    if (alternativas.length >= 3 && alternativas.length <= 5) {
      questions.push({
        tipo: 'me',
        enunciado,
        alternativas,
        gabarito,
        comentario
      });
      continue; // Added continue
    } else if (alternativas.length === 0) { // Changed condition: only check for 0 alternatives for VF
       questions.push({
         tipo: 'vf',
         enunciado,
         gabarito,
         comentario
       });
       continue; // Added continue
    }
    // If none of the above matched, it might be an invalid block
    // console.warn("Block didn't match any known question type:", block);
  }
  return questions;
}

/* --------------  autoEmbedImages (Copied from V1) -------------- */
function autoEmbedImages(text) {
  if (!text) return "";
  return text.replace(
    /(https?:\/\/\S+\.(?:png|jpe?g|gif|webp))/gi,
    '<img src="$1" alt="<imagem da questão>">'
  );
}

/* ---------------------------  RENDER QUIZ  --------------------------- */
function renderQuiz() {
  const quizDiv = document.getElementById('quiz');
  quizDiv.innerHTML = '';

  questions.forEach((q, idx) => {
    const block = document.createElement('div');
    block.className = 'question-block';

    /* -----------  ENUNCIADO (trata vf‑variante)  ----------- */
    let enunciadoHtml = q.enunciado;
    if (q.tipo === 'vf-variante') {
        const origIdx = shuffledQuestionsOrder[idx];
        const vIdx = variantSelections[origIdx];
        // Add checks for undefined/null before accessing variants
        if (q.variantes && vIdx !== null && vIdx !== undefined && q.variantes[vIdx]) {
            const variant = q.variantes[vIdx];
            enunciadoHtml = variant.enunciado;
        } else {
             // Fallback or error handling if variant data is missing
             enunciadoHtml = q.enunciado || "[Erro: Variante não encontrada]";
             console.error(`Error rendering vf-variant: Missing data for qIndex ${idx}, origIdx ${origIdx}, vIdx ${vIdx}`);
        }
    }
    block.innerHTML += `<div class="enunciado"><strong>${idx+1}.</strong> ${enunciadoHtml}</div>`;


    /* --------------  MÚLTIPLA ESCOLHA (Copied from V1) -------------- */
    if (q.tipo === 'me') {
      const altDiv = document.createElement('div');
      altDiv.className = 'alternatives';
      const origIdx = shuffledQuestionsOrder[idx];
      const altOrder = shuffledAlternativesOrders[origIdx];
      altOrder.forEach((letra, i) => {
        const alt = q.alternativas.find(a => a.letra === letra);
        const visLetra = String.fromCharCode(65 + i);
        const label = document.createElement('label');
        label.innerHTML = `<input type="radio" name="q${idx}" value="${letra}">
          <strong>${visLetra})</strong>
          <span class="alt-text-content">${alt ? alt.texto : ''}</span>`;
        addEliminationButton(label);
        altDiv.appendChild(label);
      });
      block.appendChild(altDiv);
      const radios = block.querySelectorAll(`input[type="radio"][name="q${idx}"]`);
      radios.forEach(r => {
        if (tempAnswers[idx] && r.value === tempAnswers[idx] && userAnswers[idx] === null) {
          r.checked = true;
        }
        r.addEventListener('change', () => {
          if (userAnswers[idx] === null) {
            tempAnswers[idx] = r.value;
            saveCurrentState();
          }
        });
      });
      const sendBtn = document.createElement('button');
      sendBtn.className = 'send-btn';
      sendBtn.textContent = 'Enviar Resposta';
      sendBtn.type = "button";
      sendBtn.addEventListener('click', () => {
        const selected = tempAnswers[idx] || "";
        checkAnswer(idx, selected, null);
        radios.forEach(r => r.disabled = true);
        sendBtn.disabled = true;
        sendBtn.style.opacity = 0.6;
        sendBtn.style.cursor = 'not-allowed';
        userAnswers[idx] = selected;
        saveCurrentState();
      });
      block.appendChild(sendBtn);
      const feedback = document.createElement('div');
      feedback.className = 'feedback';
      feedback.id = `feedback${idx}`;
      block.appendChild(feedback);
    }

    /* --------------  V ou F tradicional (Copied from V1) -------------- */
    else if (q.tipo === 'vf') {
      const altDiv = document.createElement('div');
      altDiv.className = 'alternatives';
      const vfAlts = [
        { letra: 'V', texto: 'Verdadeiro' },
        { letra: 'F', texto: 'Falso' }
      ];
      vfAlts.forEach((alt, i) => {
        const label = document.createElement('label');
        label.innerHTML = `<input type="radio" name="q${idx}" value="${alt.letra}"> <strong>${alt.letra})</strong> ${alt.texto}`;
        altDiv.appendChild(label);
      });
      block.appendChild(altDiv);
      const radios = block.querySelectorAll(`input[type="radio"][name="q${idx}"]`);
      radios.forEach(r => {
        if (tempAnswers[idx] && r.value === tempAnswers[idx] && userAnswers[idx] === null) {
          r.checked = true;
        }
        r.addEventListener('change', () => {
          if (userAnswers[idx] === null) {
            tempAnswers[idx] = r.value;
            saveCurrentState();
          }
        });
      });
      const sendBtn = document.createElement('button');
      sendBtn.className = 'send-btn';
      sendBtn.textContent = 'Enviar Resposta';
      sendBtn.type = "button";
      sendBtn.addEventListener('click', () => {
        const selected = tempAnswers[idx] || "";
        checkAnswer(idx, selected, null);
        radios.forEach(r => r.disabled = true);
        sendBtn.disabled = true;
        sendBtn.style.opacity = 0.6;
        sendBtn.style.cursor = 'not-allowed';
        userAnswers[idx] = selected;
        saveCurrentState();
      });
      block.appendChild(sendBtn);
      const feedback = document.createElement('div');
      feedback.className = 'feedback';
      feedback.id = `feedback${idx}`;
      block.appendChild(feedback);
    }

    /* --------------  V ou F com VARIANTES (From V2) ------------- */
    else if (q.tipo === 'vf-variante') {
      // This part remains from V2 - Renders standard V/F options
      const altDiv  = document.createElement('div');
      altDiv.className = 'alternatives';
      const vfAlts = [
        { letra:'V', texto:'Verdadeiro' },
        { letra:'F', texto:'Falso' }
      ];
      vfAlts.forEach(alt => {
        const label = document.createElement('label');
        label.innerHTML = `<input type="radio" name="q${idx}" value="${alt.letra}"><strong>${alt.letra})</strong> ${alt.texto}`;
        altDiv.appendChild(label);
      });
      block.appendChild(altDiv);

      const radios = block.querySelectorAll(`input[type="radio"][name="q${idx}"]`);
      radios.forEach(r => {
        if (tempAnswers[idx] && r.value === tempAnswers[idx] && userAnswers[idx] === null) r.checked = true;
        r.addEventListener('change', () => {
          if (userAnswers[idx] === null) {
            tempAnswers[idx] = r.value;
            saveCurrentState();
          }
        });
      });

      const sendBtn = document.createElement('button');
      sendBtn.className = 'send-btn';
      sendBtn.textContent = 'Enviar Resposta';
      sendBtn.type = "button";
      sendBtn.addEventListener('click', () => {
        const selected = tempAnswers[idx] || "";
        checkAnswer(idx, selected, null);
        radios.forEach(r => r.disabled = true);
        sendBtn.disabled = true;
        sendBtn.style.opacity = 0.6;
        sendBtn.style.cursor  = 'not-allowed';
        userAnswers[idx] = selected;
        saveCurrentState();
      });
      block.appendChild(sendBtn);

      const feedback = document.createElement('div');
      feedback.className = 'feedback';
      feedback.id = `feedback${idx}`;
      block.appendChild(feedback);
    }

    /* --------------  CHECKBOX (Copied from V1) ------------- */
    else if (q.tipo === 'checkbox') {
      const origIdx = shuffledQuestionsOrder[idx];
      const order = shuffledCheckboxOrders[origIdx];
      const altDiv = document.createElement('div');
      altDiv.className = 'alternatives';
      order.forEach((assertIdx, i) => {
        const assertive = q.assertives[assertIdx];
        const label = document.createElement('label');
        label.innerHTML = `<input type="checkbox" name="q${idx}-assert" value="${assertIdx}">
          <span class="alt-text-content">${assertive.texto}</span>`;
        addEliminationButton(label);
        altDiv.appendChild(label);
        const cmtDiv = document.createElement('div');
        cmtDiv.className = 'assertive-feedback';
        cmtDiv.id = `feedback${idx}-assert${assertIdx}`;
        cmtDiv.style.display = "none";
        altDiv.appendChild(cmtDiv);
      });
      block.appendChild(altDiv);
      const checks = block.querySelectorAll(`input[type="checkbox"][name="q${idx}-assert"]`);
      if (Array.isArray(tempAnswers[idx]) && userAnswers[idx] === null) {
        checks.forEach(chk => {
          if (tempAnswers[idx].includes(Number(chk.value))) chk.checked = true;
        });
      }
      checks.forEach(chk => {
        chk.addEventListener('change', () => {
          if (userAnswers[idx] === null) {
            tempAnswers[idx] = Array.from(checks).filter(c => c.checked).map(c => Number(c.value));
            saveCurrentState();
          }
        });
      });
      const sendBtn = document.createElement('button');
      sendBtn.className = 'send-btn';
      sendBtn.textContent = 'Enviar Resposta';
      sendBtn.type = "button";
      sendBtn.addEventListener('click', () => {
        const selecionadas = Array.from(checks).filter(c => c.checked).map(c => Number(c.value));
        checkCheckboxAnswer(idx, selecionadas, null); // Uses dedicated function
        checks.forEach(c => c.disabled = true);
        sendBtn.disabled = true;
        sendBtn.style.opacity = 0.6;
        sendBtn.style.cursor = 'not-allowed';
        userAnswers[idx] = selecionadas.slice();
        saveCurrentState();
      });
      block.appendChild(sendBtn);
      const feedback = document.createElement('div');
      feedback.className = 'feedback';
      feedback.id = `feedback${idx}`;
      block.appendChild(feedback);
    }

    /* -------------- ESCRITA (Copied from V1) ------------- */
    else if (q.tipo === 'escrita') {
      const writeDiv = document.createElement('div');
      writeDiv.className = 'write-block';
      const textarea = document.createElement('textarea');
      textarea.id = `escrita-input-${idx}`;
      if (userAnswers[idx] !== null) textarea.value = userAnswers[idx];
      else if (tempAnswers[idx]) textarea.value = tempAnswers[idx];
      textarea.placeholder = "Digite sua resposta aqui...";
      textarea.autocomplete = "off";
      textarea.spellcheck = true;
      textarea.addEventListener('input', (e) => {
        if (userAnswers[idx] === null) {
          tempAnswers[idx] = e.target.value;
          autoGrow(e);
          saveCurrentState();
        }
      });
      const sendBtn = document.createElement('button');
      sendBtn.className = 'send-btn';
      sendBtn.textContent = 'Enviar Resposta';
      sendBtn.type = "button";
      sendBtn.addEventListener('click', () => {
        enviarRespostaEscrita(idx); // Uses dedicated function
        saveCurrentState();
      });
      writeDiv.appendChild(textarea);
      writeDiv.appendChild(sendBtn);
      block.appendChild(writeDiv);
      const feedback = document.createElement('div');
      feedback.className = 'feedback neutral';
      feedback.id = `feedback${idx}`;
      feedback.style.display = 'none';
      block.appendChild(feedback);
      const selfEvalDiv = document.createElement('div');
      selfEvalDiv.className = 'self-eval-block';
      selfEvalDiv.id = `selfeval-${idx}`;
      selfEvalDiv.style.display = 'none';
      const evalLabel = document.createElement('span');
      evalLabel.className = 'self-eval-label';
      evalLabel.textContent = 'Autoavaliação:';
      selfEvalDiv.appendChild(evalLabel);
      for (let i = 0; i <= 10; i++) {
        const btn = document.createElement('button');
        btn.className = 'self-eval-btn';
        btn.textContent = i;
        btn.setAttribute('data-value', i);
        btn.type = "button";
        btn.addEventListener('click', () => {
          avaliarEscrita(idx, i); // Uses dedicated function
          saveCurrentState();
        });
        selfEvalDiv.appendChild(btn);
      }
      block.appendChild(selfEvalDiv);
    }

    /* -------------- ESCRITA-ITENS (Copied from V1) ------------- */
else if (q.tipo === 'escrita-itens') {
  const writeDiv = document.createElement('div');
  writeDiv.className = 'write-block';

  // Garante arrays válidos
  if (!Array.isArray(escritaItensRespostas[idx])) escritaItensRespostas[idx] = Array(q.itens.length).fill("");
  if (!Array.isArray(escritaItensAutoNotas[idx])) escritaItensAutoNotas[idx] = Array(q.itens.length).fill(null);
  if (!Array.isArray(tempAnswers[idx])) tempAnswers[idx] = Array(q.itens.length).fill("");
  if (!Array.isArray(userAnswers[idx])) userAnswers[idx] = Array(q.itens.length).fill(undefined);

  q.itens.forEach((item, i) => {
    // Label do item
    const label = document.createElement('label');
    label.className = 'escrita-item-label';
    label.setAttribute('for', `escrita-itens-input-${idx}-${i}`);
    label.innerHTML = `<strong>${item.letra})</strong> ${item.texto}`;
    writeDiv.appendChild(label);

    // Textarea do item
    const textarea = document.createElement('textarea');
    textarea.id = `escrita-itens-input-${idx}-${i}`;
    textarea.placeholder = "Digite sua resposta para este item...";
    textarea.autocomplete = "off";
    textarea.spellcheck = true;
    textarea.value = (userAnswers[idx][i] !== undefined) ? userAnswers[idx][i]
      : (tempAnswers[idx][i] !== undefined ? tempAnswers[idx][i] : "");
    textarea.disabled = (userAnswers[idx][i] !== undefined);
    textarea.style.background = textarea.disabled ? '#e1e6f8' : '';
    textarea.style.borderColor = '#adc9ff';
    textarea.addEventListener('input', (e) => {
      if (userAnswers[idx][i] === undefined) {
        tempAnswers[idx][i] = e.target.value;
        autoGrow(e);
        saveCurrentState();
      }
    });
    writeDiv.appendChild(textarea);

    // Botão de envio individual para o item
    const sendBtn = document.createElement('button');
    sendBtn.className = 'send-btn';
    sendBtn.textContent = 'Enviar Resposta';
    sendBtn.type = "button";
    sendBtn.disabled = (userAnswers[idx][i] !== undefined);
    sendBtn.style.opacity = sendBtn.disabled ? 0.6 : "";
    sendBtn.style.cursor = sendBtn.disabled ? 'not-allowed' : '';
    sendBtn.addEventListener('click', () => {
      enviarRespostaEscritaItem(idx, i); // Função adaptada abaixo
      saveCurrentState();
    });
    writeDiv.appendChild(sendBtn);

    // Gabarito do item (feedback)
    const feedback = document.createElement('div');
    feedback.className = 'feedback neutral';
    feedback.id = `feedback${idx}-item${i}`;
    feedback.style.display = (userAnswers[idx][i] !== undefined) ? 'block' : 'none';
    feedback.innerHTML = `<strong>Gabarito (item ${item.letra}):</strong><br>${item.gabarito}`;
    writeDiv.appendChild(feedback);

    // Autoavaliação por item
    const selfEvalDiv = document.createElement('div');
    selfEvalDiv.className = 'self-eval-block';
    selfEvalDiv.id = `selfeval-${idx}-item${i}`;
    selfEvalDiv.style.display = (userAnswers[idx][i] !== undefined) ? 'flex' : 'none';
    const evalLabel = document.createElement('span');
    evalLabel.className = 'self-eval-label';
    evalLabel.textContent = `Autoavaliação (item ${item.letra}):`;
    selfEvalDiv.appendChild(evalLabel);
    for (let nota = 0; nota <= 10; nota++) {
      const btn = document.createElement('button');
      btn.className = 'self-eval-btn';
      btn.textContent = nota;
      btn.setAttribute('data-value', nota);
      btn.type = "button";
      if (escritaItensAutoNotas[idx] && escritaItensAutoNotas[idx][i] === nota) {
        btn.classList.add('selected');
      }
      btn.addEventListener('click', () => {
        avaliarEscritaItem(idx, i, nota);
        saveCurrentState();
      });
      selfEvalDiv.appendChild(btn);
    }
    writeDiv.appendChild(selfEvalDiv);

  });

  block.appendChild(writeDiv);
}


    quizDiv.appendChild(block);
  });

  /* --- RESTAURA ESTADOS SALVOS (Copied/adapted from V1 + V2) --- */
  questions.forEach((q, idx) => {
    // ME, VF, VF-Variante
    if (q.tipo === 'me' || q.tipo === 'vf' || q.tipo === 'vf-variante') {
      if (userAnswers[idx] !== null) {
        const radios = document.getElementsByName(`q${idx}`);
        radios.forEach(r => {
          if (r.value === userAnswers[idx]) r.checked = true;
          r.disabled = true;
        });
        checkAnswer(idx, userAnswers[idx], null, true); // Use 'true' for restoring flag
        const btn = radios[0] ? radios[0].closest('.question-block').querySelector('.send-btn') : null;
        if (btn) {
          btn.disabled = true;
          btn.style.opacity = 0.6;
          btn.style.cursor = 'not-allowed';
        }
      }
    }
    // Checkbox
    else if (q.tipo === 'checkbox') {
      if (userAnswers[idx] !== null) { // userAnswers[idx] should be an array here
        const checks = document.querySelectorAll(`input[type="checkbox"][name="q${idx}-assert"]`);
        if (Array.isArray(userAnswers[idx])) {
          checks.forEach(chk => {
            if (userAnswers[idx].includes(Number(chk.value))) chk.checked = true;
            chk.disabled = true;
          });
        }
        checkCheckboxAnswer(idx, userAnswers[idx], null, true); // Use 'true' for restoring flag
        const btn = checks[0] ? checks[0].closest('.question-block').querySelector('.send-btn') : null;
        if (btn) {
          btn.disabled = true;
          btn.style.opacity = 0.6;
          btn.style.cursor = 'not-allowed';
        }
      }
    }
    // Escrita (Traditional)
    else if (q.tipo === 'escrita') {
      if (userAnswers[idx] !== null) { // userAnswers[idx] is the string response
        const textarea = document.getElementById(`escrita-input-${idx}`);
        textarea.value = userAnswers[idx];
        autoGrow({target: textarea}); // Adjust height
        textarea.disabled = true;
        textarea.style.background = '#e1e6f8';
        textarea.style.borderColor = '#adc9ff';
        const sendBtn = textarea.nextSibling; // Assumes button is next sibling
        if (sendBtn && sendBtn.classList.contains('send-btn')) {
            sendBtn.disabled = true;
            sendBtn.style.opacity = 0.6;
            sendBtn.style.cursor = 'not-allowed';
        }
        const feedback = document.getElementById(`feedback${idx}`);
        feedback.innerHTML = `<strong>Gabarito:</strong><br>${questions[idx].gabarito}`;
        feedback.className = 'feedback neutral';
        feedback.style.display = 'block';

        const selfEvalDiv = document.getElementById(`selfeval-${idx}`);
        selfEvalDiv.style.display = 'flex'; // Show self-eval
         if (escritaAutoNotas[idx] !== null) { // Check if a score exists
              const buttons = selfEvalDiv.querySelectorAll('.self-eval-btn');
              buttons.forEach(btn => {
                  btn.classList.remove('selected'); // Clear previous selections
                  if (Number(btn.getAttribute('data-value')) === escritaAutoNotas[idx]) {
                      btn.classList.add('selected');
                  }
              });
         } else {
            // Optionally, select '0' by default if no score exists yet
            const zeroButton = selfEvalDiv.querySelector('.self-eval-btn[data-value="0"]');
            if(zeroButton) zeroButton.classList.add('selected');
            // Make sure escritaAutoNotas[idx] is actually 0 if we default visually
            // avaliarEscrita(idx, 0); // Be careful with side effects here during restore
         }
      }
    }
    // Escrita por Itens
    else if (q.tipo === 'escrita-itens') {
      // Check if userAnswers for this question exists and is an array
      if (userAnswers[idx] && Array.isArray(userAnswers[idx])) {
          let allItemsAnswered = true; // Flag to check if all textareas are filled
          q.itens.forEach((item, i) => {
              const textarea = document.getElementById(`escrita-itens-input-${idx}-${i}`);
              if (textarea) {
                 // Check if a specific answer exists for this item
                 if (userAnswers[idx][i] !== undefined) {
                      textarea.value = userAnswers[idx][i];
                      textarea.disabled = true;
                      textarea.style.background = '#e1e6f8';
                      textarea.style.borderColor = '#adc9ff';
                      autoGrow({target: textarea}); // Adjust height

                      const feedback = document.getElementById(`feedback${idx}-item${i}`);
                      if (feedback) feedback.style.display = 'block'; // Show feedback

                      const selfEvalDiv = document.getElementById(`selfeval-${idx}-item${i}`);
                      if (selfEvalDiv) {
                          selfEvalDiv.style.display = 'flex'; // Show self-eval
                          // Restore selected score button
                          if (escritaItensAutoNotas[idx] && escritaItensAutoNotas[idx][i] !== null) {
                              const buttons = selfEvalDiv.querySelectorAll('.self-eval-btn');
                              buttons.forEach(btn => {
                                  btn.classList.remove('selected');
                                  if (Number(btn.getAttribute('data-value')) === escritaItensAutoNotas[idx][i]) {
                                      btn.classList.add('selected');
                                  }
                              });
                          } else {
                             // Optionally select '0' if no score yet
                             const zeroButton = selfEvalDiv.querySelector('.self-eval-btn[data-value="0"]');
                             if(zeroButton) zeroButton.classList.add('selected');
                            // avaliarEscritaItem(idx, i, 0); // Careful with side effects
                          }
                      }
                 } else {
                    // If this specific item wasn't answered, the whole question isn't fully submitted
                    allItemsAnswered = false;
                 }
              } else {
                allItemsAnswered = false; // Textarea not found
              }
          });

          // Disable the main send button only if ALL items were answered
          if (allItemsAnswered) {
              const blockElement = quizDiv.children[idx]; // Get the question block
              const sendBtn = blockElement ? blockElement.querySelector('.send-btn') : null;
              if (sendBtn) {
                  sendBtn.disabled = true;
                  sendBtn.style.opacity = 0.6;
                  sendBtn.style.cursor = 'not-allowed';
              }
          }
      }
    }

  });
  // Restore score display if quiz was finished
  if (isQuizFinished()) {
     showScore();
  }

  document.getElementById('submitAll').style.display = questions.length ? 'block' : 'none';
  
}


/* ---------  FUNÇÕES AUX. (Copied/adapted from V1) --------- */

function addEliminationButton(label) {
  const btn = document.createElement('button');
  btn.type = "button";
  btn.className = "alt-elim-btn";
  btn.title = "Eliminar/Restaurar alternativa";
  btn.tabIndex = 0; // Make it focusable
  btn.innerText = "✂️";
  btn.setAttribute("aria-label", "Eliminar alternativa");
  btn.addEventListener('click', function(e) {
    e.preventDefault(); // Prevent label's default action (checking radio/checkbox)
    e.stopPropagation(); // Prevent event from bubbling up to label
    const textSpan = label.querySelector('.alt-text-content'); // Target the text span
    if (textSpan) { // Check if span exists
        textSpan.classList.toggle('eliminada');
        // Update title/aria-label for accessibility
        if (textSpan.classList.contains('eliminada')) {
            btn.title = "Restaurar alternativa";
            btn.setAttribute("aria-label", "Restaurar alternativa");
        } else {
            btn.title = "Eliminar alternativa";
            btn.setAttribute("aria-label", "Eliminar alternativa");
        }
    } else {
        // Fallback if structure is different (e.g., VF) - might toggle the whole label
         label.classList.toggle('eliminada');
          if (label.classList.contains('eliminada')) {
            btn.title = "Restaurar alternativa";
            btn.setAttribute("aria-label", "Restaurar alternativa");
        } else {
            btn.title = "Eliminar alternativa";
            btn.setAttribute("aria-label", "Eliminar alternativa");
        }
    }
  });
  label.appendChild(btn);
}


function autoGrow(e) {
  const el = e.target;
  el.style.height = 'auto'; // Temporarily shrink to get the correct scrollHeight
  el.style.height = (el.scrollHeight) + 'px';
}

function formatComentarioLetraShuffle(comentario, altOrder) {
  if (!comentario) return "";
  let letraMap = {};
  altOrder.forEach((origLetra, index) => {
      letraMap[origLetra] = String.fromCharCode(65 + index); // Map original (A-E) to visible (A-E based on shuffle)
  });

  // Replace {A}, {B} etc. with the *visible* shuffled letter
  return comentario.replace(/\{([A-E])\}/g, (match, origLetra) => {
    return letraMap[origLetra] ? `<strong>${letraMap[origLetra]}</strong>` : match; // Return bolded visible letter or original match if not found
  });
}


function checkCheckboxAnswer(qIdx, selecionadas, visIdx, restoring = false) {
    const question = questions[qIdx];
    if (!question || question.tipo !== 'checkbox') return; // Basic validation

    if (!Array.isArray(selecionadas)) selecionadas = []; // Ensure it's an array

    let acertos = 0;
    const n = question.assertives.length;
    const origIdx = shuffledQuestionsOrder[qIdx];
    const order = shuffledCheckboxOrders[origIdx] || [...Array(n).keys()]; // Use order or default if missing

    for (let i = 0; i < n; i++) {
        const assertIdx = order[i]; // Original index of the assertive
        if (assertIdx === undefined || !question.assertives[assertIdx]) continue; // Skip if index or assertive is invalid

        const assertive = question.assertives[assertIdx];
        const checked = selecionadas.includes(assertIdx); // Check if the *original index* was selected
        const gabarito = assertive.gabarito === "V";
        const correto = (checked === gabarito);

        if (correto) acertos++;

        // Update individual assertive feedback
        const feedbackDiv = document.getElementById(`feedback${qIdx}-assert${assertIdx}`);
        if (feedbackDiv) {
            feedbackDiv.style.display = "block";
            if (correto) {
                feedbackDiv.className = "assertive-feedback correct";
                feedbackDiv.innerHTML = '<b><span style="color: #228b22;">Você julgou CORRETAMENTE a assertiva!</span></b>';
            } else {
                feedbackDiv.className = "assertive-feedback incorrect";
                feedbackDiv.innerHTML = '<b><span style="color: #d5001a;">Você julgou INCORRETAMENTE a assertiva!</span></b>';
            }
            if (assertive.comentario) {
                feedbackDiv.innerHTML += "<br>" + assertive.comentario;
            }
        }
    }

    const nota = n > 0 ? acertos / n : 0; // Calculate score (0 if no assertives)

    // Update score only if not restoring state
    if (!restoring) {
        // Need to recalculate total check score potentially
        // Let's assume scoreCheck holds the sum of individual question scores (0 to 1)
        // Find previous score for this question if it exists and subtract it
         // This recalculation logic might be better placed in showScore()
         // For now, just add the new score (might lead to double counting if answered multiple times before submitAll)
         // A better approach: store individual question scores and sum them in showScore()
         // Let's stick to the original simple addition for now:
        // scoreCheck += nota; // This can overestimate if corrected later. ShowScore needs robustness.
         // Let's store the individual score instead:
         if (!window.individualScores) window.individualScores = {};
         if (!window.individualScores.check) window.individualScores.check = [];
         window.individualScores.check[qIdx] = nota; // Store score for this question index

    }


    // Update general feedback for the question block
    const feedback = document.getElementById(`feedback${qIdx}`);
    if(feedback){
        feedback.innerHTML = `Acertou ${acertos} de ${n} assertivas. Nota: ${(nota * 10).toFixed(2)} / 10`;
        if (nota === 1) feedback.className = "feedback correct";
        else if (acertos === 0 && n > 0) feedback.className = "feedback incorrect"; // Incorrect only if score is 0
        else feedback.className = "feedback neutral"; // Partial or not yet answered
    }


    // Check if quiz is finished only if not restoring
    if (!restoring && isQuizFinished()) {
        showScore();
    }
}

function enviarRespostaEscrita(qIdx) {
  if (userAnswers[qIdx] !== null) return; // Already submitted

  const textarea = document.getElementById(`escrita-input-${qIdx}`);
  if (!textarea) return;

  const resposta = textarea.value.trim();
  userAnswers[qIdx] = resposta; // Store the answer permanently

  const feedback = document.getElementById(`feedback${qIdx}`);
  if (feedback && questions[qIdx] && questions[qIdx].gabarito) {
      feedback.innerHTML = `<strong>Gabarito:</strong><br>${questions[qIdx].gabarito}`;
      feedback.className = 'feedback neutral'; // Show gabarito neutrally
      feedback.style.display = 'block';
  }

  textarea.disabled = true;
  textarea.style.background = '#e1e6f8';
  textarea.style.borderColor = '#adc9ff';

  const sendBtn = textarea.nextSibling; // Assumes button is next
   if (sendBtn && sendBtn.classList.contains('send-btn')) {
        sendBtn.disabled = true;
        sendBtn.style.opacity = 0.6;
        sendBtn.style.cursor = 'not-allowed';
   }


  const selfEvalDiv = document.getElementById(`selfeval-${qIdx}`);
  if (selfEvalDiv) {
      selfEvalDiv.style.display = 'flex'; // Show self-evaluation block
      // Default to 0 if no score exists yet
      if (escritaAutoNotas[qIdx] === null) {
          avaliarEscrita(qIdx, 0); // Set default score and update UI
      } else {
          // Just ensure the existing score is visually selected
           avaliarEscrita(qIdx, escritaAutoNotas[qIdx]);
      }
  }
   if (isQuizFinished()) showScore(); // Check completion
   saveCurrentState(); // Save state after submission
}


function avaliarEscrita(qIdx, nota) {
    // Ensure the array exists
    if (!Array.isArray(escritaAutoNotas)) escritaAutoNotas = [];

    // Store the grade
    escritaAutoNotas[qIdx] = nota;

    const selfEvalDiv = document.getElementById(`selfeval-${qIdx}`);
    if (selfEvalDiv) {
        const buttons = selfEvalDiv.querySelectorAll('.self-eval-btn');
        buttons.forEach(btn => {
            // Check button's value and toggle 'selected' class accordingly
            btn.classList.toggle('selected', Number(btn.getAttribute('data-value')) === nota);
        });
    }

    // Update the overall score display if the quiz is finished
    if (isQuizFinished()) {
      showScore();
    }
    saveCurrentState(); // Save state after evaluation
}

function enviarRespostaEscritaItem(qIdx, i) {
  const q = questions[qIdx];
  if (!q || q.tipo !== 'escrita-itens') return;

  if (!Array.isArray(userAnswers[qIdx])) userAnswers[qIdx] = Array(q.itens.length).fill(undefined);
  if (!Array.isArray(tempAnswers[qIdx])) tempAnswers[qIdx] = Array(q.itens.length).fill("");

  // Só salva se ainda não enviado
  if (userAnswers[qIdx][i] === undefined) {
    userAnswers[qIdx][i] = (tempAnswers[qIdx][i] !== undefined) ? tempAnswers[qIdx][i].trim() : "";
  }

  // Desabilita textarea e botão, mostra feedback e autoavaliação
  const textarea = document.getElementById(`escrita-itens-input-${qIdx}-${i}`);
  if (textarea) {
    textarea.value = userAnswers[qIdx][i];
    textarea.disabled = true;
    textarea.style.background = '#e1e6f8';
    textarea.style.borderColor = '#adc9ff';
  }
  // Desabilita o botão de envio desse item
  const sendBtn = textarea ? textarea.nextSibling : null;
  if (sendBtn && sendBtn.classList.contains('send-btn')) {
    sendBtn.disabled = true;
    sendBtn.style.opacity = 0.6;
    sendBtn.style.cursor = 'not-allowed';
  }
  // Feedback (gabarito)
  const feedback = document.getElementById(`feedback${qIdx}-item${i}`);
  if (feedback) feedback.style.display = 'block';

  // Autoavaliação
  const selfEvalDiv = document.getElementById(`selfeval-${qIdx}-item${i}`);
  if (selfEvalDiv) {
    selfEvalDiv.style.display = 'flex';
    if (!escritaItensAutoNotas[qIdx] || escritaItensAutoNotas[qIdx][i] === null || escritaItensAutoNotas[qIdx][i] === undefined) {
      avaliarEscritaItem(qIdx, i, 0); // Inicializa autoavaliação em 0
    } else {
      avaliarEscritaItem(qIdx, i, escritaItensAutoNotas[qIdx][i]);
    }
  }

  if (isQuizFinished()) showScore();
  saveCurrentState();
}


function enviarRespostaEscritaItens(qIdx) {
  const q = questions[qIdx];
  if (!q || q.tipo !== 'escrita-itens') return;

  // Ensure userAnswers and tempAnswers are arrays of the correct length
  if (!Array.isArray(userAnswers[qIdx])) userAnswers[qIdx] = Array(q.itens.length).fill(undefined);
  if (!Array.isArray(tempAnswers[qIdx])) tempAnswers[qIdx] = Array(q.itens.length).fill("");

  let allSubmitted = true; // Flag to check if everything got processed

  for (let i = 0; i < q.itens.length; i++) {
      // Only update userAnswers if it's currently undefined (not previously submitted)
      if (userAnswers[qIdx][i] === undefined) {
          userAnswers[qIdx][i] = (tempAnswers[qIdx][i] !== undefined) ? tempAnswers[qIdx][i].trim() : "";
      }

      // Get elements for the current item
      const textarea = document.getElementById(`escrita-itens-input-${qIdx}-${i}`);
      const feedback = document.getElementById(`feedback${qIdx}-item${i}`);
      const selfEvalDiv = document.getElementById(`selfeval-${qIdx}-item${i}`);

      if (textarea) {
          textarea.value = userAnswers[qIdx][i]; // Display the final answer
          textarea.disabled = true;
          textarea.style.background = '#e1e6f8';
          textarea.style.borderColor = '#adc9ff';
      } else { allSubmitted = false; } // Mark as not fully processed if element missing

      if (feedback) {
          feedback.style.display = 'block'; // Show gabarito
      } else { allSubmitted = false; }

      if (selfEvalDiv) {
          selfEvalDiv.style.display = 'flex'; // Show self-evaluation
          // Default score to 0 if not already set
          if (!escritaItensAutoNotas[qIdx] || escritaItensAutoNotas[qIdx][i] === null || escritaItensAutoNotas[qIdx][i] === undefined) {
             avaliarEscritaItem(qIdx, i, 0); // Set default score and update UI
          } else {
             // Ensure existing score is visually selected
              avaliarEscritaItem(qIdx, i, escritaItensAutoNotas[qIdx][i]);
          }
      } else { allSubmitted = false; }
  }

  // Disable the main send button for the block if all items processed
  if(allSubmitted) {
      const blockElement = quizDiv.children[idx]; // Get the question block
      const sendBtn = blockElement ? blockElement.querySelector('.send-btn') : null;
      if (sendBtn) {
          sendBtn.disabled = true;
          sendBtn.style.opacity = 0.6;
          sendBtn.style.cursor = 'not-allowed';
      }
  }

  if (isQuizFinished()) showScore(); // Check completion
  saveCurrentState(); // Save state after submission
}


function avaliarEscritaItem(qIdx, i, nota) {
    // Ensure the outer array exists
    if (!Array.isArray(escritaItensAutoNotas)) escritaItensAutoNotas = [];
    // Ensure the inner array exists
    if (!Array.isArray(escritaItensAutoNotas[qIdx])) escritaItensAutoNotas[qIdx] = Array(questions[qIdx].itens.length).fill(null);

    // Store the grade for the specific item
    escritaItensAutoNotas[qIdx][i] = nota;

    // Update the UI for the specific item's evaluation block
    const selfEvalDiv = document.getElementById(`selfeval-${qIdx}-item${i}`);
    if (selfEvalDiv) {
        const buttons = selfEvalDiv.querySelectorAll('.self-eval-btn');
        buttons.forEach(btn => {
            // Toggle 'selected' based on the button's value and the chosen nota
            btn.classList.toggle('selected', Number(btn.getAttribute('data-value')) === nota);
        });
    }

    // Update the overall score display if the quiz is finished
    if (isQuizFinished()) {
        showScore();
    }
     saveCurrentState(); // Save state after evaluation
}


function isQuizFinished() {
    if (!questions || questions.length === 0) return false; // No questions loaded

    for (let i = 0; i < questions.length; i++) {
        const q = questions[i];
        const userAnswer = userAnswers[i];

        if (userAnswer === null || userAnswer === undefined) {
            return false; // Any unanswered question means not finished
        }

        // For writing questions, check if self-evaluation is done
        if (q.tipo === 'escrita') {
            if (escritaAutoNotas[i] === null || escritaAutoNotas[i] === undefined) {
                return false; // Needs self-evaluation score
            }
        } else if (q.tipo === 'escrita-itens') {
            // Check if userAnswers is an array and all items are answered
            if (!Array.isArray(userAnswer) || userAnswer.length !== q.itens.length || userAnswer.some(item => item === undefined)) {
                 return false; // Not all items submitted
            }
            // Check if self-evaluation scores exist and are complete
            if (!escritaItensAutoNotas[i] || !Array.isArray(escritaItensAutoNotas[i]) || escritaItensAutoNotas[i].length !== q.itens.length || escritaItensAutoNotas[i].some(score => score === null || score === undefined)) {
                return false; // Needs all self-evaluation scores for items
            }
        }
        // ME, VF, VF-Variante, Checkbox only need userAnswer != null check (already done)
    }

    return true; // All questions answered and evaluated where necessary
}


function shuffleArray(arr) {
  const a = arr.slice(); // Create a copy
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]]; // Swap elements
  }
  return a;
}


/* -----------------  CHECKANSWER – inclui vf‑variante (Adapted from V1/V2)  ----------------- */
function checkAnswer(qIdx, selectedLetra, visIdx, restoring = false) { // Default restoring to false
    const question = questions[qIdx];
    const feedback = document.getElementById(`feedback${qIdx}`);

    if (!question || !feedback) return; // Exit if question or feedback div not found

    // Store answer only if not restoring state
    if (!restoring) {
        userAnswers[qIdx] = (selectedLetra === null || selectedLetra === undefined) ? "" : selectedLetra;
    }

    let isCorrect = false; // Initialize correctness flag

    /* MULTIPLA ESCOLHA (Copied from V1) */
    if (question.tipo === 'me') {
        const origIdx = shuffledQuestionsOrder[qIdx];
        const altOrder = shuffledAlternativesOrders[origIdx] || question.alternativas.map(a => a.letra); // Fallback if shuffle order missing
        const correctLetra = question.gabarito;
        const userAnswer = userAnswers[qIdx]; // Use the stored answer

        isCorrect = (userAnswer === correctLetra);
        const correctAltData = question.alternativas.find(a => a.letra === correctLetra);
        const correctVisibleIndex = altOrder.indexOf(correctLetra); // Index based on shuffled order
        const correctVisibleLetra = correctVisibleIndex !== -1 ? String.fromCharCode(65 + correctVisibleIndex) : '?'; // A, B, C...

        if (isCorrect) {
            feedback.innerHTML = '<span style="color: #228b22;"><b>CORRETO!</b></span>';
            if (question.comentario) {
                feedback.innerHTML += '<br>' + formatComentarioLetraShuffle(question.comentario, altOrder);
            }
            feedback.className = 'feedback correct';
            if (!restoring) {
                 if (!window.individualScores) window.individualScores = {};
                 if (!window.individualScores.me) window.individualScores.me = [];
                 window.individualScores.me[qIdx] = 1; // Store score
                 // scoreME++; // Let showScore calculate totals
            }
        } else {
            feedback.innerHTML = `<span style="color: #d5001a;"><b>INCORRETO!</b></span> Resposta:<br> <strong>${correctVisibleLetra})</strong> ${correctAltData ? correctAltData.texto : ''}.<br>`;
            if (question.comentario) {
                feedback.innerHTML += '<br>' + formatComentarioLetraShuffle(question.comentario, altOrder);
            }
            feedback.className = 'feedback incorrect';
             if (!restoring) {
                 if (!window.individualScores) window.individualScores = {};
                 if (!window.individualScores.me) window.individualScores.me = [];
                 window.individualScores.me[qIdx] = 0; // Store score
                 // No scoreME++ here
            }
        }
    }

    /* V ou F tradicional (Copied from V1) */
    else if (question.tipo === 'vf') {
        const userAnswer = userAnswers[qIdx]; // Use stored answer
        isCorrect = (userAnswer === question.gabarito);

        if (isCorrect) {
            feedback.innerHTML = '<span style="color: #228b22;"><b>CORRETO!</b></span>';
            if (question.comentario) {
                feedback.innerHTML += '<br>' + question.comentario;
            }
            feedback.className = 'feedback correct';
            if (!restoring){
                if (!window.individualScores) window.individualScores = {};
                 if (!window.individualScores.vf) window.individualScores.vf = [];
                 window.individualScores.vf[qIdx] = 1; // Store score
                // scoreVF++; // Let showScore calculate totals
            }
        } else {
            const correctText = question.gabarito === 'V' ? 'Verdadeiro' : 'Falso';
            feedback.innerHTML = `<span style="color: #d5001a;"><b>INCORRETO!</b></span> Resposta:<br> <strong>${question.gabarito})</strong> ${correctText}.<br>`;
            if (question.comentario) {
                feedback.innerHTML += '<br>' + question.comentario;
            }
            feedback.className = 'feedback incorrect';
            if (!restoring){
                if (!window.individualScores) window.individualScores = {};
                 if (!window.individualScores.vf) window.individualScores.vf = [];
                 window.individualScores.vf[qIdx] = 0; // Store score
                // No scoreVF++ here
            }
        }
    }

    /* V ou F com variantes (From V2) */
    else if (question.tipo === 'vf-variante') {
        const origIdx = shuffledQuestionsOrder[qIdx];
        const vIdx = variantSelections[origIdx];
        // Add checks for valid variant data
        if (vIdx === null || vIdx === undefined || !question.variantes || !question.variantes[vIdx]) {
             feedback.innerHTML = '[Erro ao verificar variante]';
             feedback.className = 'feedback incorrect';
             console.error("Error checking vf-variant: Missing data", qIdx, origIdx, vIdx);
        } else {
            const variant = question.variantes[vIdx];
            const userAnswer = userAnswers[qIdx]; // Use stored answer
            isCorrect = (userAnswer === variant.gabarito);

            if (isCorrect) {
                feedback.innerHTML = '<span style="color: #228b22;"><b>CORRETO!</b></span>';
                if (variant.comentario) feedback.innerHTML += '<br>' + variant.comentario;
                feedback.className = 'feedback correct';
                if (!restoring) {
                     if (!window.individualScores) window.individualScores = {};
                     if (!window.individualScores.vf) window.individualScores.vf = [];
                     window.individualScores.vf[qIdx] = 1; // Store score (counts as VF)
                    // scoreVF++; // Let showScore calculate totals
                }
            } else {
                const correctTxt = variant.gabarito === 'V' ? 'Verdadeiro' : 'Falso';
                feedback.innerHTML = `<span style="color: #d5001a;"><b>INCORRETO!</b></span> Resposta:<br> <strong>${variant.gabarito})</strong> ${correctTxt}.<br>`;
                if (variant.comentario) feedback.innerHTML += '<br>' + variant.comentario;
                feedback.className = 'feedback incorrect';
                 if (!restoring) {
                     if (!window.individualScores) window.individualScores = {};
                     if (!window.individualScores.vf) window.individualScores.vf = [];
                     window.individualScores.vf[qIdx] = 0; // Store score (counts as VF)
                    // No scoreVF++ here
                }
            }
        }
    }

    /* checkbox, escrita etc are handled in their dedicated functions (checkCheckboxAnswer, enviarRespostaEscrita...) */

    // Check if quiz finished and update score display, only if not restoring
    if (!restoring && isQuizFinished()) {
        showScore();
    }
     // Save state after checking (important for ME/VF types)
     if(!restoring) saveCurrentState();
}


/* ----------------  showScore ajustado (conta vf‑variante)  ------------- */
function showScore() {
  // Totais e contadores
  let totalME = 0, totalVF = 0, totalCheck = 0, totalEscrita = 0;
  let correctME = 0, correctVF = 0;
  let pontosCheck = 0, pontosEscrita = 0;

  // Percorre todas as questões
  questions.forEach((q, idx) => {
    // Múltipla Escolha
    if (q.tipo === 'me') {
      totalME++;
      if (window.individualScores && window.individualScores.me && window.individualScores.me[idx] !== undefined)
        correctME += window.individualScores.me[idx];
    }
    // Verdadeiro ou Falso (inclui variantes)
    else if (q.tipo === 'vf' || q.tipo === 'vf-variante') {
      totalVF++;
      if (window.individualScores && window.individualScores.vf && window.individualScores.vf[idx] !== undefined)
        correctVF += window.individualScores.vf[idx];
    }
    // Checkbox
    else if (q.tipo === 'checkbox') {
      totalCheck++;
      if (window.individualScores && window.individualScores.check && window.individualScores.check[idx] !== undefined)
        pontosCheck += window.individualScores.check[idx];
    }
    // Escrita "tradicional"
    else if (q.tipo === 'escrita') {
      totalEscrita++;
      const nota = (escritaAutoNotas && escritaAutoNotas[idx] !== undefined) ? escritaAutoNotas[idx] : null;
      if (Number.isFinite(nota) && nota >= 0 && nota <= 10) {
        pontosEscrita += nota / 10;
      }
    }
    // Escrita com itens
    else if (q.tipo === 'escrita-itens') {
      totalEscrita++;
      // Checa array de auto notas por item
      const notas = (escritaItensAutoNotas && escritaItensAutoNotas[idx]) ? escritaItensAutoNotas[idx] : null;
      let soma = 0, nItensValidos = 0;
      if (Array.isArray(notas) && notas.length === q.itens.length) {
        for (let i = 0; i < notas.length; i++) {
          const n = notas[i];
          if (Number.isFinite(n) && n >= 0 && n <= 10) {
            soma += n / 10;
            nItensValidos++;
          }
        }
      }
      // Só soma se todos os itens da questão foram autoavaliados (se não quiser isso, pode mudar a regra aqui)
      if (nItensValidos === q.itens.length && q.itens.length > 0) {
        pontosEscrita += soma / q.itens.length;
      }
      // Se quiser considerar parcialmente (mesmo se só alguns itens foram avaliados), troque por:
      // if (nItensValidos > 0) pontosEscrita += soma / nItensValidos;
    }
  });

  // Calcula notas individuais
  let notaME      = totalME > 0      ? ((correctME / totalME) * 10).toFixed(2)      : null;
  let notaVF      = totalVF > 0      ? ((correctVF / totalVF) * 10).toFixed(2)      : null;
  let notaCheck   = totalCheck > 0   ? ((pontosCheck / totalCheck) * 10).toFixed(2) : null;
  let notaEscrita = totalEscrita > 0 ? ((pontosEscrita / totalEscrita) * 10).toFixed(2) : null;

  // Nota geral
  let totalPontos = correctME + correctVF + pontosCheck + pontosEscrita;
  let totalQ      = totalME + totalVF + totalCheck + totalEscrita;
  let notaGeral   = totalQ > 0 ? ((totalPontos / totalQ)*10).toFixed(2) : "--";

  // Monta tabela (só linhas dos tipos presentes)
  let html = `<div id="score-table-container">
    <div class="score-title">Relatório de Desempenho</div>
    <table id="score-table">
      <tbody>
  `;
  if (notaME !== null) html += `
    <tr>
      <td class="score-type">Múltipla escolha</td>
      <td class="score-note">${notaME} / 10</td>
      <td class="score-detail">${correctME} de ${totalME} acertos</td>
    </tr>`;
  if (notaVF !== null) html += `
    <tr>
      <td class="score-type">Verdadeiro ou Falso</td>
      <td class="score-note">${notaVF} / 10</td>
      <td class="score-detail">${correctVF} de ${totalVF} acertos</td>
    </tr>`;
  if (notaCheck !== null) html += `
    <tr>
      <td class="score-type">Checkbox</td>
      <td class="score-note">${notaCheck} / 10</td>
      <td class="score-detail">${pontosCheck.toFixed(2)} de ${totalCheck} pontos</td>
    </tr>`;
  if (notaEscrita !== null) html += `
    <tr>
      <td class="score-type">Escrita</td>
      <td class="score-note">${notaEscrita} / 10</td>
      <td class="score-detail">${pontosEscrita.toFixed(2)} de ${totalEscrita} pontos</td>
    </tr>`;

  // Nota geral sempre em destaque
  html += `
    <tr id="score-overall-row">
      <td colspan="3">
        Nota Geral: <span style="font-size:1.20em;color:#0c8659;font-weight:900">${notaGeral} / 10</span>
        <div style="font-size:0.98em;color:#57797a; margin-top:2px;">(${totalPontos.toFixed(2)} de ${totalQ} pontos possíveis)</div>
      </td>
    </tr>
  `;
  html += `</tbody></table></div>`;

  document.getElementById('score').innerHTML = html;
}



/* ---------------  SALVA/LOAD LOCALSTORAGE (V2/V3)  ---------------- */
const STORAGE_KEY = "quiz-txt-app-state-v3"; // Use V3 key
function saveState(st) { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(st)); } catch(e) { console.error("Failed to save state:", e); } }
function loadState()    { try { const loaded = localStorage.getItem(STORAGE_KEY); return loaded ? JSON.parse(loaded) : null;} catch(e) { console.error("Failed to load state:", e); return null;} }
function clearState() {
  try { localStorage.removeItem(STORAGE_KEY); }
  catch(e){}
}


function saveCurrentState(quizTextOverride) {
  const state = {
    quizText: quizTextOverride !== undefined ? quizTextOverride : null,
    quizTextHash,
    shuffledQuestionsOrder,
    shuffledAlternativesOrders,
    shuffledCheckboxOrders,
    variantSelections,                       // <<< Include variant selections
    shuffleQuestionsLocked,
    userAnswers,
    tempAnswers,
    escritaAutoNotas,
    escritaItensAutoNotas,
    escritaItensRespostas,
    // Store individual scores instead of totals for accuracy
    individualScores: window.individualScores || { me: [], vf: [], check: [] },
    // Keep total scores for potential backward compatibility or quick display (optional)
    scoreME, scoreVF, scoreCheck, scoreEscrita,
    shuffleQuestions: shuffleQuestionsChk.checked,
    shuffleAlternatives: shuffleAlternativesChk.checked,
	currentQuizTitle
  };
  /* garante texto salvo */
  if (!state.quizText) {
      const prev = loadState(); // Load previous state if text override is not provided
      // Only use previous text if the hash matches (ensures it's the same quiz)
      if (prev && prev.quizTextHash === quizTextHash && prev.quizText) {
           state.quizText = prev.quizText;
      } else if (originalQuestions.length > 0 && !state.quizText) {
          // Fallback: try to reconstruct from originalQuestions if possible (less reliable)
          // This part is complex and might not be feasible/necessary.
          // console.warn("Quiz text could not be saved reliably.");
      }
  }

  saveState(state);
}


/* -------------  SUBMIT ALL EVENT LISTENER (Copied from V1) ------------- */
document.getElementById('submitAll').addEventListener('click', () => {
  questions.forEach((q, idx) => {

    // --- MÚLTIPLA ESCOLHA, VF, VF-VARIANTE ---
    if (q.tipo === 'me' || q.tipo === 'vf' || q.tipo === 'vf-variante') {
      if (userAnswers[idx] === null) {
        const radios = document.getElementsByName(`q${idx}`);
        let selected = null;
        radios.forEach(r => { if (r.checked) selected = r.value; });
        checkAnswer(idx, selected, null, false);
      }
    }

    // --- CHECKBOX ---
    else if (q.tipo === 'checkbox') {
      if (userAnswers[idx] === null) {
        const checks = document.querySelectorAll(`input[name="q${idx}-assert"]`);
        const marcadas = Array.from(checks).filter(c => c.checked).map(c => Number(c.value));
        userAnswers[idx] = marcadas.slice();
        checkCheckboxAnswer(idx, marcadas, null, false);
        checks.forEach(c => c.disabled = true);
        const btnCh = checks[0] && checks[0].closest('.question-block').querySelector('.send-btn');
        if (btnCh) { btnCh.disabled = true; btnCh.style.opacity = 0.6; btnCh.style.cursor = 'not-allowed'; }
      }
    }

    // --- ESCRITA TRADICIONAL ---
    else if (q.tipo === 'escrita') {
      if (userAnswers[idx] === null) {
        enviarRespostaEscrita(idx);
      }
    }

    // --- ESCRITA COM ITENS (ENVIA TODOS DE UMA SÓ VEZ) ---
    else if (q.tipo === 'escrita-itens') {
      // Garante arrays em userAnswers e tempAnswers
      if (!Array.isArray(userAnswers[idx]))        userAnswers[idx] = Array(q.itens.length).fill("");
      if (!Array.isArray(tempAnswers[idx]))        tempAnswers[idx] = Array(q.itens.length).fill("");
      if (!Array.isArray(escritaItensAutoNotas[idx])) escritaItensAutoNotas[idx] = Array(q.itens.length).fill(null);

      // Para cada item: lê, salva, desabilita, mostra feedback e autoavaliação
      q.itens.forEach((item, i) => {
        const ta    = document.getElementById(`escrita-itens-input-${idx}-${i}`);
        const fb    = document.getElementById(`feedback${idx}-item${i}`);
        const self  = document.getElementById(`selfeval-${idx}-item${i}`);

        if (ta && !ta.disabled) {
          // Salva a resposta
          userAnswers[idx][i] = ta.value.trim();
          // Desabilita textarea
          ta.disabled = true;
          ta.style.background   = '#e1e6f8';
          ta.style.borderColor  = '#adc9ff';

          // Exibe gabarito
          if (fb) fb.style.display = 'block';

          // Exibe autoavaliação (e define 0 se ainda não tiver nota)
          if (self) {
            self.style.display = 'flex';
            const notaAtual = escritaItensAutoNotas[idx][i];
            const notaFinal = (Number.isFinite(notaAtual) && notaAtual >= 0 && notaAtual <= 10)
                              ? notaAtual : 0;
            avaliarEscritaItem(idx, i, notaFinal);
          }
        }
      });
    }

  }); // fim do forEach questions

  // Depois de processar TUDO:
  showScore();
  renderQuiz();
  window.scrollTo(0, document.documentElement.scrollHeight);
  saveCurrentState();
});



/* -------------------  ZOOM DE IMAGEM (Copied from V1)  ------------------- */
function openImageModal(src){const m=document.getElementById('imgModal');const i=document.getElementById('imgModalImg');i.src=src;m.classList.add('open');}
function closeImageModal(){document.getElementById('imgModal').classList.remove('open');}
document.getElementById('quiz').addEventListener('click',e=>{
  if(e.target.tagName.toLowerCase()==='img')openImageModal(e.target.src);
});
</script>
</body>
</html>

